{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Trabajando con teselas vectoriales Bienvenidos al taller de teselas vectoriales. Este manual est\u00e1 publicado aqu\u00ed: https://geoinquiets.github.io/taller-vt/ Autores Wladimir Szczerban (alias Bolo) @bolosig , geostarter (ICGC) Oscar Fonts @oscarfonts , desarrollador freelance en geomati.co Y ambos somos geoinquiets ! Condiciones de reutilizaci\u00f3n de estos apuntes Estos materiales est\u00e1n publicados bajo licencia CreativeCommons (by-sa) 4.0 internacional Usted es libre de: Compartir \u2014 copiar y redistribuir el material en cualquier medio o formato Adaptar \u2014 remezclar, transformar y crear a partir del material para cualquier finalidad, incluso comercial. Bajo las condiciones siguientes: Reconocimiento \u2014 Debe reconocer adecuadamente la autor\u00eda, proporcionar un enlace a la licencia e indicar si se han realizado cambios. Puede hacerlo de cualquier manera razonable, pero no de una manera que sugiera que tiene el apoyo del licenciador o lo recibe por el uso que hace. CompartirIgual \u2014 Si remezcla, transforma o crea a partir del material, deber\u00e1 difundir sus contribuciones bajo la misma licencia que el original. * No hay restricciones adicionales \u2014 No puede aplicar t\u00e9rminos legales o medidas tecnol\u00f3gicas que legalmente restrinjan realizar aquello que la licencia permite. Esenciales para moverse por OSGeo Live Usuario: \"user\" Password: \"user\" Para lanzar un programa de forma r\u00e1pida: Men\u00fa inicio = Ejecutar Shift + Ctrl + V para pegar un texto del portapapeles en el terminal Descarga de los materiales para el taller 1 2 3 4 5 cd Desktop wget https://geoinquiets.github.io/taller-vt/downloads/taller-vt.zip unzip taller-vt.zip cd taller-vt ll As\u00ed pues, la ruta ~/Desktop/taller-vt ser\u00e1 nuestro directorio base, donde iremos creando los recursos necesarios. De momento tenemos los subdirectorios: datos maputnik Comprobaci\u00f3n del software preinstalado En el aula de la pr\u00e1ctica se ha preinstalado una serie de software necesario para el taller. En caso de que falte alguno, se pueden consultar las instrucciones de instalaci\u00f3n en el siguiente apartado. Comandos de comprobaci\u00f3n: Alt + F2 = \"terminator\" deber\u00eda abrir un terminal. google-chrome http://tileserver.fonts.cat/styles/dark-matter/style.json deber\u00eda abrir Chrome y mostrar un JSON formateado y coloreado. google-chrome http://tileserver.fonts.cat/styles/dark-matter-3d/?vector#16.09/41.3861/2.19226/-47.2/60 deber\u00eda mostrar un mapa de Barcelona con edificios en 3D, y moverse con soltura. node -v Deber\u00eda ser 6.x.x (NO mayor que 6, si aparece 8.x.x o 10.x.x, hay que cambiar de versi\u00f3n) npm -v code -v tippecanoe -v Instalaci\u00f3n de requisitos de software El software de base para el taller ya est\u00e1 instalado en los ordenadores del aula, pero indicamos aqu\u00ed c\u00f3mo instalarlo tomando como base OSGeo Live 11 (tambi\u00e9n valdr\u00e1 para Ubuntu 16.04, en el que adem\u00e1s deber\u00eda instalarse PostGIS). Google Chrome La extensi\u00f3n json-viewer en Chrome Microsoft Visual Studio Code Terminator: 1 sudo apt install terminator node6 y npm (sobre nvm): Primero, instalar nvm: 1 curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.8/install.sh | bash Cerrar y reabrir el terminal. Luego, instalar node 6 y npm: 1 2 3 4 5 nvm install 6 npm install -g npm # comprobar versiones node -v # Deber\u00eda ser 6.x.x npm -v # Deber\u00eda ser 6.x.x o mayor tippecanoe: Instalar dependencias (librer\u00edas sqlite3 y zlib): 1 sudo apt install build-essential libsqlite3-dev zlib1g-dev Bajarse el c\u00f3digo fuente: 1 2 git clone https://github.com/mapbox/tippecanoe.git cd tippecanoe Compilar: 1 2 make -j sudo make install Comprobar la instalaci\u00f3n: 1 tippecanoe -v # Devolver\u00e1, por ejemplo, v1.29.0 Una vez instalado el ejecutable, podemos borrar el c\u00f3digo fuente: 1 2 cd .. rm -rf tippecanoe Danger Todo el taller se basa en tener un navegador con capacidades WebGL, que deber\u00eda poder moverse R\u00c1PIDO. Comprobar que al abrirse esta p\u00e1gina, se ve un mapa de Barcelona con edificios: http://tileserver.fonts.cat/styles/dark-matter-3d/?vector#16.09/41.3861/2.19226/-47.2/60 Comprobar que el mapa se mueve con soltura. Si no se puede correr el SO nativo (ser\u00eda lo ideal), ajustar la configuraci\u00f3n de VirtualBox para tener activadas las opciones: System Processor \"Enable PAE/NX\" Display Screen Aumentar MB disponibles para la tarjeta gr\u00e1fica. Display Screen \"Enable 3D acceleration\". Tener instaladas las \"VirtualBox Guest Additions\" en la m\u00e1quina virtual. Recursos adicionales Mayormente de Raf , nuestra fuente diaria de vitaminas, v\u00eda Geoinquiets . Awesome Vector Tiles Natural Earth Vector Tiles by Lukas Martinelli Tutorial de los Geoinquietos de Londres Tilemaker, de OSM a mbtiles de una tacada Qu\u00e9 son las teselas vectoriales (vector tiles) y c\u00f3mo generarlos con PostGIS / GeoServer Natural Earth Quickstart Style implemented with Tegola GeoServer MBStyle Cookbook GeoServer MBStyle Styling Workbook","title":"Home"},{"location":"#trabajando-con-teselas-vectoriales","text":"Bienvenidos al taller de teselas vectoriales. Este manual est\u00e1 publicado aqu\u00ed:","title":"Trabajando con teselas vectoriales"},{"location":"#httpsgeoinquietsgithubiotaller-vt","text":"","title":"https://geoinquiets.github.io/taller-vt/"},{"location":"#autores","text":"Wladimir Szczerban (alias Bolo) @bolosig , geostarter (ICGC) Oscar Fonts @oscarfonts , desarrollador freelance en geomati.co Y ambos somos geoinquiets ! Condiciones de reutilizaci\u00f3n de estos apuntes Estos materiales est\u00e1n publicados bajo licencia CreativeCommons (by-sa) 4.0 internacional Usted es libre de: Compartir \u2014 copiar y redistribuir el material en cualquier medio o formato Adaptar \u2014 remezclar, transformar y crear a partir del material para cualquier finalidad, incluso comercial. Bajo las condiciones siguientes: Reconocimiento \u2014 Debe reconocer adecuadamente la autor\u00eda, proporcionar un enlace a la licencia e indicar si se han realizado cambios. Puede hacerlo de cualquier manera razonable, pero no de una manera que sugiera que tiene el apoyo del licenciador o lo recibe por el uso que hace. CompartirIgual \u2014 Si remezcla, transforma o crea a partir del material, deber\u00e1 difundir sus contribuciones bajo la misma licencia que el original. * No hay restricciones adicionales \u2014 No puede aplicar t\u00e9rminos legales o medidas tecnol\u00f3gicas que legalmente restrinjan realizar aquello que la licencia permite.","title":"Autores"},{"location":"#esenciales-para-moverse-por-osgeo-live","text":"Usuario: \"user\" Password: \"user\" Para lanzar un programa de forma r\u00e1pida: Men\u00fa inicio = Ejecutar Shift + Ctrl + V para pegar un texto del portapapeles en el terminal","title":"Esenciales para moverse por OSGeo Live"},{"location":"#descarga-de-los-materiales-para-el-taller","text":"1 2 3 4 5 cd Desktop wget https://geoinquiets.github.io/taller-vt/downloads/taller-vt.zip unzip taller-vt.zip cd taller-vt ll As\u00ed pues, la ruta ~/Desktop/taller-vt ser\u00e1 nuestro directorio base, donde iremos creando los recursos necesarios. De momento tenemos los subdirectorios: datos maputnik","title":"Descarga de los materiales para el taller"},{"location":"#comprobacion-del-software-preinstalado","text":"En el aula de la pr\u00e1ctica se ha preinstalado una serie de software necesario para el taller. En caso de que falte alguno, se pueden consultar las instrucciones de instalaci\u00f3n en el siguiente apartado. Comandos de comprobaci\u00f3n: Alt + F2 = \"terminator\" deber\u00eda abrir un terminal. google-chrome http://tileserver.fonts.cat/styles/dark-matter/style.json deber\u00eda abrir Chrome y mostrar un JSON formateado y coloreado. google-chrome http://tileserver.fonts.cat/styles/dark-matter-3d/?vector#16.09/41.3861/2.19226/-47.2/60 deber\u00eda mostrar un mapa de Barcelona con edificios en 3D, y moverse con soltura. node -v Deber\u00eda ser 6.x.x (NO mayor que 6, si aparece 8.x.x o 10.x.x, hay que cambiar de versi\u00f3n) npm -v code -v tippecanoe -v","title":"Comprobaci\u00f3n del software preinstalado"},{"location":"#instalacion-de-requisitos-de-software","text":"El software de base para el taller ya est\u00e1 instalado en los ordenadores del aula, pero indicamos aqu\u00ed c\u00f3mo instalarlo tomando como base OSGeo Live 11 (tambi\u00e9n valdr\u00e1 para Ubuntu 16.04, en el que adem\u00e1s deber\u00eda instalarse PostGIS). Google Chrome La extensi\u00f3n json-viewer en Chrome Microsoft Visual Studio Code Terminator: 1 sudo apt install terminator node6 y npm (sobre nvm): Primero, instalar nvm: 1 curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.8/install.sh | bash Cerrar y reabrir el terminal. Luego, instalar node 6 y npm: 1 2 3 4 5 nvm install 6 npm install -g npm # comprobar versiones node -v # Deber\u00eda ser 6.x.x npm -v # Deber\u00eda ser 6.x.x o mayor tippecanoe: Instalar dependencias (librer\u00edas sqlite3 y zlib): 1 sudo apt install build-essential libsqlite3-dev zlib1g-dev Bajarse el c\u00f3digo fuente: 1 2 git clone https://github.com/mapbox/tippecanoe.git cd tippecanoe Compilar: 1 2 make -j sudo make install Comprobar la instalaci\u00f3n: 1 tippecanoe -v # Devolver\u00e1, por ejemplo, v1.29.0 Una vez instalado el ejecutable, podemos borrar el c\u00f3digo fuente: 1 2 cd .. rm -rf tippecanoe Danger Todo el taller se basa en tener un navegador con capacidades WebGL, que deber\u00eda poder moverse R\u00c1PIDO. Comprobar que al abrirse esta p\u00e1gina, se ve un mapa de Barcelona con edificios: http://tileserver.fonts.cat/styles/dark-matter-3d/?vector#16.09/41.3861/2.19226/-47.2/60 Comprobar que el mapa se mueve con soltura. Si no se puede correr el SO nativo (ser\u00eda lo ideal), ajustar la configuraci\u00f3n de VirtualBox para tener activadas las opciones: System Processor \"Enable PAE/NX\" Display Screen Aumentar MB disponibles para la tarjeta gr\u00e1fica. Display Screen \"Enable 3D acceleration\". Tener instaladas las \"VirtualBox Guest Additions\" en la m\u00e1quina virtual.","title":"Instalaci\u00f3n de requisitos de software"},{"location":"#recursos-adicionales","text":"Mayormente de Raf , nuestra fuente diaria de vitaminas, v\u00eda Geoinquiets . Awesome Vector Tiles Natural Earth Vector Tiles by Lukas Martinelli Tutorial de los Geoinquietos de Londres Tilemaker, de OSM a mbtiles de una tacada Qu\u00e9 son las teselas vectoriales (vector tiles) y c\u00f3mo generarlos con PostGIS / GeoServer Natural Earth Quickstart Style implemented with Tegola GeoServer MBStyle Cookbook GeoServer MBStyle Styling Workbook","title":"Recursos adicionales"},{"location":"1_teoria/","text":"Qu\u00e9 son las teselas vectoriales Presentaci\u00f3n Ver este cap\u00edtulo en formato presentaci\u00f3n Las teselas vectoriales son un formato de datos liviano para almacenar datos vectoriales geoespaciales, como puntos, l\u00edneas y pol\u00edgonos. Las teselas vectoriales codifican informaci\u00f3n geogr\u00e1fica de acuerdo con la especificaci\u00f3n de teselas vector de Mapbox. La especificaci\u00f3n de Mapbox es un est\u00e1ndar abierto bajo una licencia Creative Commons Attribution 3.0 US. Una tesela vectorial (vector tiles) contiene datos vectoriales georreferenciados (puede contener m\u00faltiples capas), recortados en teselas para facilitar su recuperaci\u00f3n. Son equivalentes a las teselas raster tradicionales (WMTS, TMS) pero retornan datos vectoriales en lugar de una imagen. Cada conjunto de teselas vectoriales tiene su propio esquema. Un esquema consiste en nombres de capas, atributos, selecci\u00f3n de elementos, etc. No existe un esquema que sirva para todo. Existen varios esquemas como por ejemplo: OpenMapTiles, Mapbox Streets, etc. Warning Las teselas vectoriales no son un formato de datos vectoriales estilo Shapefile, GeoJSON, etc. pensado para trabajar (hacer an\u00e1lisis, explotaci\u00f3n de datos, etc.) sino que est\u00e1 pensado y enfocado principalmente en la visualizaci\u00f3n. Un poco de Historia Fechas destacadas 1966 Sistema de Informaci\u00f3n Geogr\u00e1fica de Canad\u00e1 (CGIS) utiliza \u201cmarco\u201d para almacenar informaci\u00f3n 1975 Servicio de Vida Silvestre EE.UU. utiliza \u201cgeounit\u201d para almacenar datos Finales de 1980 teselas se vuelven \u201cinvisibles\u201d para el usuario final. Manejo de datos continuo Abril 2014 Mapbox saca la version 1.0 de la especificaci\u00f3n Mapbox Vector Tile Existe una larga historia de uso de teselas vectoriales en SIG. En 1966 el Sistema de Informaci\u00f3n Geogr\u00e1fica de Canad\u00e1 (CGIS), utilizaba un esquema de almacenamiento vectorial que permit\u00eda a las computadoras de recursos limitados acceder de manera eficiente y procesar datos de mapas vectoriales. CGIS us\u00f3 el t\u00e9rmino \"marco\" en lugar de teselas vectoriales. En 1975, el Servicio de Vida Silvestre de los EE.UU. inici\u00f3 un programa nacional para mapear y digitalizar todos los humedales de los EE.UU. En 1976 desarrollan un software que se llam\u00f3 WAMS (Wetlands Analytical Mapping System). El almacenage de datos del WAMS usaba una estructura de teselas vectorial. Cada tesela se llamaba \"geounit\". Una geounit correspond\u00eda a una de las escalas cuadrangulares del USGS, generalmente 1:24000. En 1986 bas\u00e1ndose en la experiencia operativa adquirida en la implementaci\u00f3n y el uso de WAMS y del Map Overlay and Statistical System (MOSS), se lanz\u00f3 un SIG comercial DeltaMap (m\u00e1s tarde GenaMap) basado en UNIX que implement\u00f3 una estructura mejorada de almacenamiento y acceso de teselas vectores. DeltaMap permiti\u00f3 al usuario definir cualquier tama\u00f1o de tesela en cualquier sistema de referencia de coordenadas (CRS). De esta forma, los datos dispersos requer\u00edan solo unas pocas teselas, mientras que los datos densos pod\u00edan usar teselas mucho m\u00e1s peque\u00f1as. Utilizaban R-trees como el esquema de indexaci\u00f3n para las teselas de vectores. A finales de la d\u00e9cada de 1980, se mejor\u00f3 a\u00fan m\u00e1s GenaMap para permitir el procesamiento \"continuo e ininterrumpido\" de las capas de teselas. B\u00e1sicamente, desde la perspectiva del usuario final, las teselas se volvieron invisibles. [^1] [^1] https://en.wikipedia.org/wiki/Vector_tiles Abril de 2014 Mapbox saca la version 1.0 de la especificaci\u00f3n Mapbox Vector Tile (MVT). Diciembre 2015 versi\u00f3n 2.0 de la especificaci\u00f3n MVT. Marzo de 2015 ESRI (el que no debe ser nombrado) anuncia que soportar\u00e1 MVT. Mapbox actualmente est\u00e1 trabajando en la versi\u00f3n 3. Diferencias entre teselas raster y teselas vectoriales Teselas vectoriales Teselas raster Estilo se define en el cliente Estilo se define en el servidor S\u00f3lo se necesita teselar la informaci\u00f3n una sola vez y se pueden tener m\u00faltiples mapas Hay que teselas la informaci\u00f3n para cada mapa Overzoom se mantiene resoluci\u00f3n Overzoom pierde resoluci\u00f3n (pixelado) Menor tama\u00f1o (se recomienda m\u00e1ximo 500kb) M\u00e1s f\u00e1ciles de consumir Cache ocupa mucho menos espacio. F\u00e1ctible el uso en dispositivos m\u00f3viles sin conexi\u00f3n Cache ocupa mucho espacio. Uso en dispositivos m\u00f3viles requiere mucho espacio de disco Acceso nativo a la informaci\u00f3n del objeto (atributos y geometr\u00eda), lo que permite un procesamiento muy sofisticado Se ven mejor en dispositivos de alta resoluci\u00f3n Comparativa pesos teselas vector vs raster. Fuente https://plot.ly/~mourner/118.embed Comparaci\u00f3n con otros formatos Teselas Vectoriales WMS WMTS WFS Nivel de zoom continuo Nivel de zoom continuo Nivel de zoom discreto Nivel de zoom continuo Teselado No teselado, con lo cual no hay problemas de etiquetas Teselado No teselado Retorna datos en vector modificados (generalizados, simplificados) Retorna imagen raster Retorna imagen raster Retorna datos en vector sin modificar Cache tanto en cliente como en servidor No cache Cache tanto en cliente como en servidor No cache Escalabilidad Escalabilidad Interactivo No interactivo (se pueden hacer consultas getFeatureInfo) No interactivo Interactivo Estilo flexible (cliente es quien define el estilo) Estilo fijo (se puede modificar via SLD pero lo renderiza el servidor) Estilo fijo (definido en el servidor) Estilo flexible Impresi\u00f3n Hi-DPI Impresi\u00f3n problemas con Hi-DPI Dif\u00edcil impresi\u00f3n (montar el mosaico de im\u00e1ges y problemas con Hi-DPI) Impresi\u00f3n Hi-DPI C\u00f3mo est\u00e1n hechas por dentro Las geometr\u00edas y los atributos se codifican como datos binarios de Google Protobuf (PBF). Codificar geometr\u00edas Para codificar informaci\u00f3n geogr\u00e1fica en una tesela vectorial, una herramienta debe convertir las coordenadas geogr\u00e1ficas, como la latitud y la longitud, en coordenadas vectoriales de cuadr\u00edculas. Las teselas de vectoriales no tienen ning\u00fan concepto de informaci\u00f3n geogr\u00e1fica. Codifican puntos, l\u00edneas y pol\u00edgonos como pares x/y relativos a la esquina superior izquierda de la cuadr\u00edcula de forma descendente. Las geometr\u00edas son transformadas a una sola tesela, con un sistema de coordenadas de p\u00edxel local, que por defecto va de la esquina superior izquierda (0,0) a la esquina inferior derecha (4096,4096). Codificar geometr\u00eda. Fuente https://www.mapbox.com/vector-tiles/specification/#encoding-geom Codificar atributos Los atributos se codifican como un conjunto \u00fanico de claves (algo as\u00ed como un esquema de campos de capa) y la lista de sus valores. Los atributos est\u00e1n codificados en una serie de etiquetas que existen dentro de un elemento en el vector que tienen valores enteros que hacen referencia a las claves y los valores que provienen de la geometr\u00eda. Esto elimina la redundancia de los atributos para geometr\u00edas que tienen las mismas claves y valores similares. Codificar atributos. Fuente https://www.mapbox.com/vector-tiles/specification/#encoding-attr Winding order El Winding order (direcci\u00f3n de digitalizaci\u00f3n) se refiere a la direcci\u00f3n en que se dibuja un anillo en un mosaico vectorial, ya sea en sentido horario o antihorario. Muchas geometr\u00edas son multipol\u00edgonos con \"agujeros\", que tambi\u00e9n se representan como anillos de pol\u00edgono. Es importante poder inferir el orden al extraer datos fuente de un mosaico vectorial y comprender si la geometr\u00eda es parte de un pol\u00edgono m\u00faltiple o un pol\u00edgono \u00fanico. Para que los procesadores distingan de manera apropiada que pol\u00edgonos son agujeros y cu\u00e1les son geometr\u00edas \u00fanicas, la especificaci\u00f3n requiere que todos los pol\u00edgonos sean v\u00e1lidos (validez de OGC). Cualquier anillo interior poligonal debe orientarse con el orden opuesto al de su anillo exterior principal y todos los anillos interiores deben seguir directamente el anillo exterior al que pertenecen. Los anillos exteriores deben estar orientados en el sentido de las agujas del reloj y los anillos interiores deben estar orientados en sentido contrario a las agujas del reloj. Winding order. Fuente https://www.mapbox.com/vector-tiles/specification/#winding-order Diferentes especificaciones y conceptos relacionados con las teselas vectoriales pbf Protocol buffers desarrollado por Google (para uso interno) es un m\u00e9todo para serializar datos estructurados. Es language-neutral , platform-neutral y en cuyo objetivo de dise\u00f1o enfatizaron la simplicidad y el rendimiento. El m\u00e9todo implica un lenguaje de descripci\u00f3n de interfaz que describe la estructura de algunos datos y un programa que genera c\u00f3digo fuente a partir de esa descripci\u00f3n para generar o analizar una secuencia de bytes que representa los datos estructurados. mvt Formato binario basado en la especificaci\u00f3n de Mapbox que usa pbf para serializar datos geogr\u00e1ficos. Los archivos deber\u00edan tener extensi\u00f3n .mvt pero no es obligatorio as\u00ed que se pueden encontrar archivos con extensi\u00f3n .pbf, .vector.pbf o .mvt.gz (compresi\u00f3n gzip) Por ejemplo un conjunto de teselas mvt almacenadas en un SQLite siguiendo una esquema espec\u00edfico formar\u00eda un MBTiles. MBTiles MBTiles es un formato de archivo para almacenar conjuntos de teselas. Est\u00e1 dise\u00f1ado para que pueda empaquetar los potencialmente miles de archivos que componen un conjunto de teselas y moverlos, usarlos en una aplicaci\u00f3n web o m\u00f3vil. MBTiles es una especificaci\u00f3n abierta y se basa en la base de datos SQLite. MBTiles puede contener conjunto de teselas reaster y/o vector. MBTiles es una especificaci\u00f3n compacta y restrictiva. S\u00f3lo admite datos teselados, incluidas teselas vectoriales o de im\u00e1genes y UTFGrid (hasta la versi\u00f3n 1.2). S\u00f3lo la proyecci\u00f3n esf\u00e9rica de Mercator es soportada para la presentaci\u00f3n (visualizaci\u00f3n) y s\u00f3lo se admiten coordenadas de latitud y longitud para metadatos, como l\u00edmites y centros. Es una especificaci\u00f3n m\u00ednima, que sol\u00f3 especifica las formas en que los datos deben ser recuperables. Por lo tanto, los archivos MBTiles pueden comprimir y optimizar datos internamente, y construir vistas que se adhieren a la especificaci\u00f3n MBTiles. Dentro del MBtiles los vectores estan almacenados comprimidos (gzip) y en formato pbf. A diferencia de Spatialite, GeoJSON y Rasterlite, MBTiles no es un almacenamiento de datos sin formato. Es almacenamiento de datos en teselas. tilejson TileJSON es un formato para describir un conjunto de teselas. Realiza un seguimiento de d\u00f3nde solicitar el conjunto de teselas, el nombre del conjunto de teselas y cualquier atribuci\u00f3n que sea necesaria al utilizar el conjunto de teselas. Esta especificaci\u00f3n intenta crear un est\u00e1ndar para representar metadatos sobre m\u00faltiples tipos de capas, para ayudar a los clientes en la configuraci\u00f3n y navegaci\u00f3n. Overzoom Overzooming es una t\u00e9cnica espec\u00edfica de teselas vectorial que permite que una tesela se represente m\u00e1s all\u00e1 de su nivel de zoom previsto, por lo que contin\u00faa siendo visible en el mapa. Si un conjunto de teselas tiene un minzoom de 6 y un maxzoom de 12, esos son los rangos v\u00e1lidos calculados por el generador de teselas. Si ampliara el mapa m\u00e1s all\u00e1 del nivel de zoom 12, el renderizador del mapa puede seguir utilizando los datos del zoom 12 escalando los datos del vector hacia arriba. Esto, por supuesto, puede dar lugar a grandes simplificaciones de datos si las geometr\u00edas se representan demasiado por encima de su nivel real de detalle. Las teselas raster pierden claridad si ocurre overzoom. Por ejemplo, si est\u00e1 visualizando un conjunto de teselas raster con una extensi\u00f3n de zoom entre z0 y z6, si hace un zoom a un nivel de zoom m\u00e1s alto despu\u00e9s de z6, las im\u00e1genes se volver\u00e1n borrosas y dif\u00edciles de ver. Los efectos del overzoom no son tan notables con las teselas vector, ya que los datos vectoriales no se almacenan en un formato basado en p\u00edxeles, sino que se codifican y calculan a partir de una serie de puntos, l\u00edneas y pol\u00edgonos. Overzoom nivel zoom 16 vs nivel zoom 19. Presentaci\u00f3n de ejemplos visuales hechos con vt Terreno https://openicgc.github.io/ Luces LA Edificios con m\u00fasica https://codepen.io/jwhazel/pen/NYzpWG blog explicativo https://medium.com/@erdag/mappox-mapmadness18-round-4-1251a8c10421 Tem\u00e1tico filtro Filtrado al vuelo Mapa de calor Esquema general de lo que se va a hacer en el taller Esquema taller","title":"1. Qu\u00e9 son"},{"location":"1_teoria/#que-son-las-teselas-vectoriales","text":"Presentaci\u00f3n Ver este cap\u00edtulo en formato presentaci\u00f3n Las teselas vectoriales son un formato de datos liviano para almacenar datos vectoriales geoespaciales, como puntos, l\u00edneas y pol\u00edgonos. Las teselas vectoriales codifican informaci\u00f3n geogr\u00e1fica de acuerdo con la especificaci\u00f3n de teselas vector de Mapbox. La especificaci\u00f3n de Mapbox es un est\u00e1ndar abierto bajo una licencia Creative Commons Attribution 3.0 US. Una tesela vectorial (vector tiles) contiene datos vectoriales georreferenciados (puede contener m\u00faltiples capas), recortados en teselas para facilitar su recuperaci\u00f3n. Son equivalentes a las teselas raster tradicionales (WMTS, TMS) pero retornan datos vectoriales en lugar de una imagen. Cada conjunto de teselas vectoriales tiene su propio esquema. Un esquema consiste en nombres de capas, atributos, selecci\u00f3n de elementos, etc. No existe un esquema que sirva para todo. Existen varios esquemas como por ejemplo: OpenMapTiles, Mapbox Streets, etc. Warning Las teselas vectoriales no son un formato de datos vectoriales estilo Shapefile, GeoJSON, etc. pensado para trabajar (hacer an\u00e1lisis, explotaci\u00f3n de datos, etc.) sino que est\u00e1 pensado y enfocado principalmente en la visualizaci\u00f3n.","title":"Qu\u00e9 son las teselas vectoriales"},{"location":"1_teoria/#un-poco-de-historia","text":"Fechas destacadas 1966 Sistema de Informaci\u00f3n Geogr\u00e1fica de Canad\u00e1 (CGIS) utiliza \u201cmarco\u201d para almacenar informaci\u00f3n 1975 Servicio de Vida Silvestre EE.UU. utiliza \u201cgeounit\u201d para almacenar datos Finales de 1980 teselas se vuelven \u201cinvisibles\u201d para el usuario final. Manejo de datos continuo Abril 2014 Mapbox saca la version 1.0 de la especificaci\u00f3n Mapbox Vector Tile Existe una larga historia de uso de teselas vectoriales en SIG. En 1966 el Sistema de Informaci\u00f3n Geogr\u00e1fica de Canad\u00e1 (CGIS), utilizaba un esquema de almacenamiento vectorial que permit\u00eda a las computadoras de recursos limitados acceder de manera eficiente y procesar datos de mapas vectoriales. CGIS us\u00f3 el t\u00e9rmino \"marco\" en lugar de teselas vectoriales. En 1975, el Servicio de Vida Silvestre de los EE.UU. inici\u00f3 un programa nacional para mapear y digitalizar todos los humedales de los EE.UU. En 1976 desarrollan un software que se llam\u00f3 WAMS (Wetlands Analytical Mapping System). El almacenage de datos del WAMS usaba una estructura de teselas vectorial. Cada tesela se llamaba \"geounit\". Una geounit correspond\u00eda a una de las escalas cuadrangulares del USGS, generalmente 1:24000. En 1986 bas\u00e1ndose en la experiencia operativa adquirida en la implementaci\u00f3n y el uso de WAMS y del Map Overlay and Statistical System (MOSS), se lanz\u00f3 un SIG comercial DeltaMap (m\u00e1s tarde GenaMap) basado en UNIX que implement\u00f3 una estructura mejorada de almacenamiento y acceso de teselas vectores. DeltaMap permiti\u00f3 al usuario definir cualquier tama\u00f1o de tesela en cualquier sistema de referencia de coordenadas (CRS). De esta forma, los datos dispersos requer\u00edan solo unas pocas teselas, mientras que los datos densos pod\u00edan usar teselas mucho m\u00e1s peque\u00f1as. Utilizaban R-trees como el esquema de indexaci\u00f3n para las teselas de vectores. A finales de la d\u00e9cada de 1980, se mejor\u00f3 a\u00fan m\u00e1s GenaMap para permitir el procesamiento \"continuo e ininterrumpido\" de las capas de teselas. B\u00e1sicamente, desde la perspectiva del usuario final, las teselas se volvieron invisibles. [^1] [^1] https://en.wikipedia.org/wiki/Vector_tiles Abril de 2014 Mapbox saca la version 1.0 de la especificaci\u00f3n Mapbox Vector Tile (MVT). Diciembre 2015 versi\u00f3n 2.0 de la especificaci\u00f3n MVT. Marzo de 2015 ESRI (el que no debe ser nombrado) anuncia que soportar\u00e1 MVT. Mapbox actualmente est\u00e1 trabajando en la versi\u00f3n 3.","title":"Un poco de Historia"},{"location":"1_teoria/#diferencias-entre-teselas-raster-y-teselas-vectoriales","text":"Teselas vectoriales Teselas raster Estilo se define en el cliente Estilo se define en el servidor S\u00f3lo se necesita teselar la informaci\u00f3n una sola vez y se pueden tener m\u00faltiples mapas Hay que teselas la informaci\u00f3n para cada mapa Overzoom se mantiene resoluci\u00f3n Overzoom pierde resoluci\u00f3n (pixelado) Menor tama\u00f1o (se recomienda m\u00e1ximo 500kb) M\u00e1s f\u00e1ciles de consumir Cache ocupa mucho menos espacio. F\u00e1ctible el uso en dispositivos m\u00f3viles sin conexi\u00f3n Cache ocupa mucho espacio. Uso en dispositivos m\u00f3viles requiere mucho espacio de disco Acceso nativo a la informaci\u00f3n del objeto (atributos y geometr\u00eda), lo que permite un procesamiento muy sofisticado Se ven mejor en dispositivos de alta resoluci\u00f3n Comparativa pesos teselas vector vs raster. Fuente https://plot.ly/~mourner/118.embed","title":"Diferencias entre teselas raster y teselas vectoriales"},{"location":"1_teoria/#comparacion-con-otros-formatos","text":"Teselas Vectoriales WMS WMTS WFS Nivel de zoom continuo Nivel de zoom continuo Nivel de zoom discreto Nivel de zoom continuo Teselado No teselado, con lo cual no hay problemas de etiquetas Teselado No teselado Retorna datos en vector modificados (generalizados, simplificados) Retorna imagen raster Retorna imagen raster Retorna datos en vector sin modificar Cache tanto en cliente como en servidor No cache Cache tanto en cliente como en servidor No cache Escalabilidad Escalabilidad Interactivo No interactivo (se pueden hacer consultas getFeatureInfo) No interactivo Interactivo Estilo flexible (cliente es quien define el estilo) Estilo fijo (se puede modificar via SLD pero lo renderiza el servidor) Estilo fijo (definido en el servidor) Estilo flexible Impresi\u00f3n Hi-DPI Impresi\u00f3n problemas con Hi-DPI Dif\u00edcil impresi\u00f3n (montar el mosaico de im\u00e1ges y problemas con Hi-DPI) Impresi\u00f3n Hi-DPI","title":"Comparaci\u00f3n con otros formatos"},{"location":"1_teoria/#como-estan-hechas-por-dentro","text":"Las geometr\u00edas y los atributos se codifican como datos binarios de Google Protobuf (PBF).","title":"C\u00f3mo est\u00e1n hechas por dentro"},{"location":"1_teoria/#codificar-geometrias","text":"Para codificar informaci\u00f3n geogr\u00e1fica en una tesela vectorial, una herramienta debe convertir las coordenadas geogr\u00e1ficas, como la latitud y la longitud, en coordenadas vectoriales de cuadr\u00edculas. Las teselas de vectoriales no tienen ning\u00fan concepto de informaci\u00f3n geogr\u00e1fica. Codifican puntos, l\u00edneas y pol\u00edgonos como pares x/y relativos a la esquina superior izquierda de la cuadr\u00edcula de forma descendente. Las geometr\u00edas son transformadas a una sola tesela, con un sistema de coordenadas de p\u00edxel local, que por defecto va de la esquina superior izquierda (0,0) a la esquina inferior derecha (4096,4096). Codificar geometr\u00eda. Fuente https://www.mapbox.com/vector-tiles/specification/#encoding-geom","title":"Codificar geometr\u00edas"},{"location":"1_teoria/#codificar-atributos","text":"Los atributos se codifican como un conjunto \u00fanico de claves (algo as\u00ed como un esquema de campos de capa) y la lista de sus valores. Los atributos est\u00e1n codificados en una serie de etiquetas que existen dentro de un elemento en el vector que tienen valores enteros que hacen referencia a las claves y los valores que provienen de la geometr\u00eda. Esto elimina la redundancia de los atributos para geometr\u00edas que tienen las mismas claves y valores similares. Codificar atributos. Fuente https://www.mapbox.com/vector-tiles/specification/#encoding-attr","title":"Codificar atributos"},{"location":"1_teoria/#winding-order","text":"El Winding order (direcci\u00f3n de digitalizaci\u00f3n) se refiere a la direcci\u00f3n en que se dibuja un anillo en un mosaico vectorial, ya sea en sentido horario o antihorario. Muchas geometr\u00edas son multipol\u00edgonos con \"agujeros\", que tambi\u00e9n se representan como anillos de pol\u00edgono. Es importante poder inferir el orden al extraer datos fuente de un mosaico vectorial y comprender si la geometr\u00eda es parte de un pol\u00edgono m\u00faltiple o un pol\u00edgono \u00fanico. Para que los procesadores distingan de manera apropiada que pol\u00edgonos son agujeros y cu\u00e1les son geometr\u00edas \u00fanicas, la especificaci\u00f3n requiere que todos los pol\u00edgonos sean v\u00e1lidos (validez de OGC). Cualquier anillo interior poligonal debe orientarse con el orden opuesto al de su anillo exterior principal y todos los anillos interiores deben seguir directamente el anillo exterior al que pertenecen. Los anillos exteriores deben estar orientados en el sentido de las agujas del reloj y los anillos interiores deben estar orientados en sentido contrario a las agujas del reloj. Winding order. Fuente https://www.mapbox.com/vector-tiles/specification/#winding-order","title":"Winding order"},{"location":"1_teoria/#diferentes-especificaciones-y-conceptos-relacionados-con-las-teselas-vectoriales","text":"","title":"Diferentes especificaciones y conceptos relacionados con las teselas vectoriales"},{"location":"1_teoria/#pbf","text":"Protocol buffers desarrollado por Google (para uso interno) es un m\u00e9todo para serializar datos estructurados. Es language-neutral , platform-neutral y en cuyo objetivo de dise\u00f1o enfatizaron la simplicidad y el rendimiento. El m\u00e9todo implica un lenguaje de descripci\u00f3n de interfaz que describe la estructura de algunos datos y un programa que genera c\u00f3digo fuente a partir de esa descripci\u00f3n para generar o analizar una secuencia de bytes que representa los datos estructurados.","title":"pbf"},{"location":"1_teoria/#mvt","text":"Formato binario basado en la especificaci\u00f3n de Mapbox que usa pbf para serializar datos geogr\u00e1ficos. Los archivos deber\u00edan tener extensi\u00f3n .mvt pero no es obligatorio as\u00ed que se pueden encontrar archivos con extensi\u00f3n .pbf, .vector.pbf o .mvt.gz (compresi\u00f3n gzip) Por ejemplo un conjunto de teselas mvt almacenadas en un SQLite siguiendo una esquema espec\u00edfico formar\u00eda un MBTiles.","title":"mvt"},{"location":"1_teoria/#mbtiles","text":"MBTiles es un formato de archivo para almacenar conjuntos de teselas. Est\u00e1 dise\u00f1ado para que pueda empaquetar los potencialmente miles de archivos que componen un conjunto de teselas y moverlos, usarlos en una aplicaci\u00f3n web o m\u00f3vil. MBTiles es una especificaci\u00f3n abierta y se basa en la base de datos SQLite. MBTiles puede contener conjunto de teselas reaster y/o vector. MBTiles es una especificaci\u00f3n compacta y restrictiva. S\u00f3lo admite datos teselados, incluidas teselas vectoriales o de im\u00e1genes y UTFGrid (hasta la versi\u00f3n 1.2). S\u00f3lo la proyecci\u00f3n esf\u00e9rica de Mercator es soportada para la presentaci\u00f3n (visualizaci\u00f3n) y s\u00f3lo se admiten coordenadas de latitud y longitud para metadatos, como l\u00edmites y centros. Es una especificaci\u00f3n m\u00ednima, que sol\u00f3 especifica las formas en que los datos deben ser recuperables. Por lo tanto, los archivos MBTiles pueden comprimir y optimizar datos internamente, y construir vistas que se adhieren a la especificaci\u00f3n MBTiles. Dentro del MBtiles los vectores estan almacenados comprimidos (gzip) y en formato pbf. A diferencia de Spatialite, GeoJSON y Rasterlite, MBTiles no es un almacenamiento de datos sin formato. Es almacenamiento de datos en teselas.","title":"MBTiles"},{"location":"1_teoria/#tilejson","text":"TileJSON es un formato para describir un conjunto de teselas. Realiza un seguimiento de d\u00f3nde solicitar el conjunto de teselas, el nombre del conjunto de teselas y cualquier atribuci\u00f3n que sea necesaria al utilizar el conjunto de teselas. Esta especificaci\u00f3n intenta crear un est\u00e1ndar para representar metadatos sobre m\u00faltiples tipos de capas, para ayudar a los clientes en la configuraci\u00f3n y navegaci\u00f3n.","title":"tilejson"},{"location":"1_teoria/#overzoom","text":"Overzooming es una t\u00e9cnica espec\u00edfica de teselas vectorial que permite que una tesela se represente m\u00e1s all\u00e1 de su nivel de zoom previsto, por lo que contin\u00faa siendo visible en el mapa. Si un conjunto de teselas tiene un minzoom de 6 y un maxzoom de 12, esos son los rangos v\u00e1lidos calculados por el generador de teselas. Si ampliara el mapa m\u00e1s all\u00e1 del nivel de zoom 12, el renderizador del mapa puede seguir utilizando los datos del zoom 12 escalando los datos del vector hacia arriba. Esto, por supuesto, puede dar lugar a grandes simplificaciones de datos si las geometr\u00edas se representan demasiado por encima de su nivel real de detalle. Las teselas raster pierden claridad si ocurre overzoom. Por ejemplo, si est\u00e1 visualizando un conjunto de teselas raster con una extensi\u00f3n de zoom entre z0 y z6, si hace un zoom a un nivel de zoom m\u00e1s alto despu\u00e9s de z6, las im\u00e1genes se volver\u00e1n borrosas y dif\u00edciles de ver. Los efectos del overzoom no son tan notables con las teselas vector, ya que los datos vectoriales no se almacenan en un formato basado en p\u00edxeles, sino que se codifican y calculan a partir de una serie de puntos, l\u00edneas y pol\u00edgonos. Overzoom nivel zoom 16 vs nivel zoom 19.","title":"Overzoom"},{"location":"1_teoria/#presentacion-de-ejemplos-visuales-hechos-con-vt","text":"","title":"Presentaci\u00f3n de ejemplos visuales hechos con vt"},{"location":"1_teoria/#terreno","text":"https://openicgc.github.io/","title":"Terreno"},{"location":"1_teoria/#luces-la","text":"","title":"Luces LA"},{"location":"1_teoria/#edificios-con-musica","text":"https://codepen.io/jwhazel/pen/NYzpWG blog explicativo https://medium.com/@erdag/mappox-mapmadness18-round-4-1251a8c10421","title":"Edificios con m\u00fasica"},{"location":"1_teoria/#tematico-filtro","text":"","title":"Tem\u00e1tico filtro"},{"location":"1_teoria/#filtrado-al-vuelo","text":"","title":"Filtrado al vuelo"},{"location":"1_teoria/#mapa-de-calor","text":"","title":"Mapa de calor"},{"location":"1_teoria/#esquema-general-de-lo-que-se-va-a-hacer-en-el-taller","text":"Esquema taller","title":"Esquema general de lo que se va a hacer en el taller"},{"location":"2_visor_simple/","text":"C\u00f3mo visualizar teselas vectoriales Servidor web Para ver las aplicaciones que desarrollaremos durante el taller necesitamos publicarlas mediante un servidor web. En nuestro caso usaremos live-server , que permite servir los contenidos de un directorio y recargar la p\u00e1gina autom\u00e1ticamente cuando se modifica el contenido de alg\u00fan fichero. Para instalarlo, se usar\u00e1 el comando: 1 npm install -g live-server Para arrancarlo, basta con situarse en el directorio que queramos servir y ejecutar: 1 2 3 4 cd ~/Desktop/taller-vt mkdir visor cd visor live-server Se abrir\u00e1 el navegador por defecto con la direcci\u00f3n http://127.0.0.1:8080/ y se mostrar\u00e1 el contenido del directorio para poder navegar por \u00e9l. Deja la ventana del terminal abierta, y usa la combinaci\u00f3n de teclas Ctrl + C para parar el servidor. Hola Mundo Vamos a crear un fichero barcelona.html . Abre una nueva ventana de terminal (recuerda dejar el servidor activo) y ejecuta Visual Studio Code (o el editor que prefieras): 1 code ~/Desktop/taller-vt Crea un fichero en el directorio visor llamado barcelona.html : 1 2 3 4 5 6 7 8 9 10 11 !DOCTYPE html html head meta charset = UTF-8 meta name = viewport content = width=device-width, initial-scale=1 title Mapa VT / title / head body id = map Hola mundo / body / html Recargar la p\u00e1gina http://127.0.0.1:8080/ en el navegador. Se deber\u00eda ver un \"Hola mundo\". Hola Mapa En este primer ejemplo crearemos un visor de mapas utilizando la librer\u00eda de Mapbox GL JS. Tanto los datos procedente de teselas vectoriales \u00f3 vector tiles (VT) como el estilo para simbolizar los mismos se encuentran en la red. Modificar el archivo barcelona.html para que contenga el siguiente c\u00f3digo: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 !DOCTYPE html html head meta charset = UTF-8 meta name = viewport content = width=device-width, initial-scale=1 title Mapa VT / title link rel = stylesheet href = https://api.tiles.mapbox.com/mapbox-gl-js/v0.44.1/mapbox-gl.css / script src = https://api.tiles.mapbox.com/mapbox-gl-js/v0.44.1/mapbox-gl.js / script style html , body { margin : 0 ; height : 100 % ; } / style / head body id = map script var map = new mapboxgl . Map ({ container : map , // id del elemento HTML que contendr\u00e1 el mapa style : https://geoserveis.icgc.cat/contextmaps/osm-bright.json , // Ubicaci\u00f3n del estilo center : [ 2.175 , 41.39 ], // Ubicaci\u00f3n inicial zoom : 13 , // Zoom inicial bearing : - 45 , // \u00c1ngulo de rotaci\u00f3n inicial hash : true // Permite ir guardando la posici\u00f3n del mapa en la URL }); // Agrega controles de navegaci\u00f3n (zoom, rotaci\u00f3n) al mapa: map . addControl ( new mapboxgl . NavigationControl ()); / script / body / html Resultado visor simple Inspector de datos El control mapbox-gl-inspect permite ver todos los elementos de un VT y tambi\u00e9n permite pasar el cursor sobre los elementos para ver sus propiedades. Agregar el c\u00f3digo de la librer\u00eda, e instanciar el control tras crear el mapa: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 !DOCTYPE html html head meta charset = UTF-8 meta name = viewport content = width=device-width, initial-scale=1 title Mapa VT / title link rel = stylesheet href = https://api.tiles.mapbox.com/mapbox-gl-js/v0.44.1/mapbox-gl.css / script src = https://api.tiles.mapbox.com/mapbox-gl-js/v0.44.1/mapbox-gl.js / script link href = https://mapbox-gl-inspect.lukasmartinelli.ch/dist/mapbox-gl-inspect.css rel = stylesheet / script src = https://mapbox-gl-inspect.lukasmartinelli.ch/dist/mapbox-gl-inspect.min.js / script style html , body { margin : 0 ; height : 100 % ; } / style / head body id = map script var map = new mapboxgl . Map ({ container : map , // id del elemento HTML que contendr\u00e1 el mapa style : https://geoserveis.icgc.cat/contextmaps/osm-bright.json , // Ubicaci\u00f3n del estilo center : [ 2.175 , 41.39 ], // Ubicaci\u00f3n inicial zoom : 13 , // Zoom inicial bearing : - 45 , // \u00c1ngulo de rotaci\u00f3n inicial hash : true // Permite ir guardando la posici\u00f3n del mapa en la URL }); // Agrega controles de navegaci\u00f3n (zoom, rotaci\u00f3n) al mapa: map . addControl ( new mapboxgl . NavigationControl ()); // Agregar el control de inspecci\u00f3n map . addControl ( new MapboxInspect ()); / script / body / html Se recargar\u00e1 la p\u00e1gina en el navegador con un nuevo bot\u00f3n que permite la \"visi\u00f3n de rayos X\" sobre los datos. Inspect Contenido de un fichero de estilo Como vemos, el visor es muy sencillo, y parece que toda la \"magia\" se esconde en el fichero de estilo tras la URL https://geoserveis.icgc.cat/contextmaps/osm-bright.json . Si lo abrimos, es un objeto JSON bastante complejo, pero si nos fijamos en las propiedades de primer nivel, son pocas. Las principales: 1 2 3 4 5 6 7 8 { version : 8 , name : OSM Bright , sprite : https://geoserveis.icgc.cat/contextmaps/sprites/sprite@1 , glyphs : https://geoserveis.icgc.cat/contextmaps/glyphs/{fontstack}/{range}.pbf , sources : { ... }, layers : [ ... ] } version es obligatoria y siempre es 8. name es opcional pero conveniente, es una etiqueta para mostrar el nombre del estilo. sprite indica de d\u00f3nde obtener el conjunto de iconos necesarios para simbolizar. glyphs : indica de d\u00f3nde obtener el conjunto de tipograf\u00edas necesarios para simbolizar. sources : los or\u00edgenes de datos. layers : las reglas de simbolizaci\u00f3n. El orden es importante: Se van dibujando de la primera (que queda por debajo) a la \u00faltima (que queda por encima). As\u00ed, la primera regla suele ser el color de fondo del mapa, y las \u00faltimas suelen ser la toponimia o los PoIs. En los pr\u00f3ximos cap\u00edtulos veremos en detalle c\u00f3mo usar sources , layers , sprites y glyphs . Habitualmente tambi\u00e9n se usan otras propiedades para indicar la vista inicial del mapa. Por ejemplo: 1 2 3 4 5 6 7 { ... center : [ 2.15 , 41.39 ], zoom : 12 , bearing : -45 , pitch : 0 } center : Coordenadas iniciales donde centrar el mapa [lon, lat] zoom : Zoom inicial del mapa bearing : Rotaci\u00f3n inicial del mapa (en grados) pitch : Inclinaci\u00f3n inicial del mapa para verlo en perspectiva (de 0 a 60 grados) Tip La especificaci\u00f3n completa del fichero de estilo es parte de la documentaci\u00f3n on-line de Mapbox GL JS . Tip Si quisi\u00e9ramos editar el fichero de estilo, basta con guardarnos una copia local junto a barcelona.html y modificar la propiedad style para apuntar a una URL relativa. Lo veremos con m\u00e1s detalle en el punto 6.","title":"2. C\u00f3mo visualizarlas"},{"location":"2_visor_simple/#como-visualizar-teselas-vectoriales","text":"","title":"C\u00f3mo visualizar teselas vectoriales"},{"location":"2_visor_simple/#servidor-web","text":"Para ver las aplicaciones que desarrollaremos durante el taller necesitamos publicarlas mediante un servidor web. En nuestro caso usaremos live-server , que permite servir los contenidos de un directorio y recargar la p\u00e1gina autom\u00e1ticamente cuando se modifica el contenido de alg\u00fan fichero. Para instalarlo, se usar\u00e1 el comando: 1 npm install -g live-server Para arrancarlo, basta con situarse en el directorio que queramos servir y ejecutar: 1 2 3 4 cd ~/Desktop/taller-vt mkdir visor cd visor live-server Se abrir\u00e1 el navegador por defecto con la direcci\u00f3n http://127.0.0.1:8080/ y se mostrar\u00e1 el contenido del directorio para poder navegar por \u00e9l. Deja la ventana del terminal abierta, y usa la combinaci\u00f3n de teclas Ctrl + C para parar el servidor.","title":"Servidor web"},{"location":"2_visor_simple/#hola-mundo","text":"Vamos a crear un fichero barcelona.html . Abre una nueva ventana de terminal (recuerda dejar el servidor activo) y ejecuta Visual Studio Code (o el editor que prefieras): 1 code ~/Desktop/taller-vt Crea un fichero en el directorio visor llamado barcelona.html : 1 2 3 4 5 6 7 8 9 10 11 !DOCTYPE html html head meta charset = UTF-8 meta name = viewport content = width=device-width, initial-scale=1 title Mapa VT / title / head body id = map Hola mundo / body / html Recargar la p\u00e1gina http://127.0.0.1:8080/ en el navegador. Se deber\u00eda ver un \"Hola mundo\".","title":"Hola Mundo"},{"location":"2_visor_simple/#hola-mapa","text":"En este primer ejemplo crearemos un visor de mapas utilizando la librer\u00eda de Mapbox GL JS. Tanto los datos procedente de teselas vectoriales \u00f3 vector tiles (VT) como el estilo para simbolizar los mismos se encuentran en la red. Modificar el archivo barcelona.html para que contenga el siguiente c\u00f3digo: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 !DOCTYPE html html head meta charset = UTF-8 meta name = viewport content = width=device-width, initial-scale=1 title Mapa VT / title link rel = stylesheet href = https://api.tiles.mapbox.com/mapbox-gl-js/v0.44.1/mapbox-gl.css / script src = https://api.tiles.mapbox.com/mapbox-gl-js/v0.44.1/mapbox-gl.js / script style html , body { margin : 0 ; height : 100 % ; } / style / head body id = map script var map = new mapboxgl . Map ({ container : map , // id del elemento HTML que contendr\u00e1 el mapa style : https://geoserveis.icgc.cat/contextmaps/osm-bright.json , // Ubicaci\u00f3n del estilo center : [ 2.175 , 41.39 ], // Ubicaci\u00f3n inicial zoom : 13 , // Zoom inicial bearing : - 45 , // \u00c1ngulo de rotaci\u00f3n inicial hash : true // Permite ir guardando la posici\u00f3n del mapa en la URL }); // Agrega controles de navegaci\u00f3n (zoom, rotaci\u00f3n) al mapa: map . addControl ( new mapboxgl . NavigationControl ()); / script / body / html Resultado visor simple","title":"Hola Mapa"},{"location":"2_visor_simple/#inspector-de-datos","text":"El control mapbox-gl-inspect permite ver todos los elementos de un VT y tambi\u00e9n permite pasar el cursor sobre los elementos para ver sus propiedades. Agregar el c\u00f3digo de la librer\u00eda, e instanciar el control tras crear el mapa: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 !DOCTYPE html html head meta charset = UTF-8 meta name = viewport content = width=device-width, initial-scale=1 title Mapa VT / title link rel = stylesheet href = https://api.tiles.mapbox.com/mapbox-gl-js/v0.44.1/mapbox-gl.css / script src = https://api.tiles.mapbox.com/mapbox-gl-js/v0.44.1/mapbox-gl.js / script link href = https://mapbox-gl-inspect.lukasmartinelli.ch/dist/mapbox-gl-inspect.css rel = stylesheet / script src = https://mapbox-gl-inspect.lukasmartinelli.ch/dist/mapbox-gl-inspect.min.js / script style html , body { margin : 0 ; height : 100 % ; } / style / head body id = map script var map = new mapboxgl . Map ({ container : map , // id del elemento HTML que contendr\u00e1 el mapa style : https://geoserveis.icgc.cat/contextmaps/osm-bright.json , // Ubicaci\u00f3n del estilo center : [ 2.175 , 41.39 ], // Ubicaci\u00f3n inicial zoom : 13 , // Zoom inicial bearing : - 45 , // \u00c1ngulo de rotaci\u00f3n inicial hash : true // Permite ir guardando la posici\u00f3n del mapa en la URL }); // Agrega controles de navegaci\u00f3n (zoom, rotaci\u00f3n) al mapa: map . addControl ( new mapboxgl . NavigationControl ()); // Agregar el control de inspecci\u00f3n map . addControl ( new MapboxInspect ()); / script / body / html Se recargar\u00e1 la p\u00e1gina en el navegador con un nuevo bot\u00f3n que permite la \"visi\u00f3n de rayos X\" sobre los datos. Inspect","title":"Inspector de datos"},{"location":"2_visor_simple/#contenido-de-un-fichero-de-estilo","text":"Como vemos, el visor es muy sencillo, y parece que toda la \"magia\" se esconde en el fichero de estilo tras la URL https://geoserveis.icgc.cat/contextmaps/osm-bright.json . Si lo abrimos, es un objeto JSON bastante complejo, pero si nos fijamos en las propiedades de primer nivel, son pocas. Las principales: 1 2 3 4 5 6 7 8 { version : 8 , name : OSM Bright , sprite : https://geoserveis.icgc.cat/contextmaps/sprites/sprite@1 , glyphs : https://geoserveis.icgc.cat/contextmaps/glyphs/{fontstack}/{range}.pbf , sources : { ... }, layers : [ ... ] } version es obligatoria y siempre es 8. name es opcional pero conveniente, es una etiqueta para mostrar el nombre del estilo. sprite indica de d\u00f3nde obtener el conjunto de iconos necesarios para simbolizar. glyphs : indica de d\u00f3nde obtener el conjunto de tipograf\u00edas necesarios para simbolizar. sources : los or\u00edgenes de datos. layers : las reglas de simbolizaci\u00f3n. El orden es importante: Se van dibujando de la primera (que queda por debajo) a la \u00faltima (que queda por encima). As\u00ed, la primera regla suele ser el color de fondo del mapa, y las \u00faltimas suelen ser la toponimia o los PoIs. En los pr\u00f3ximos cap\u00edtulos veremos en detalle c\u00f3mo usar sources , layers , sprites y glyphs . Habitualmente tambi\u00e9n se usan otras propiedades para indicar la vista inicial del mapa. Por ejemplo: 1 2 3 4 5 6 7 { ... center : [ 2.15 , 41.39 ], zoom : 12 , bearing : -45 , pitch : 0 } center : Coordenadas iniciales donde centrar el mapa [lon, lat] zoom : Zoom inicial del mapa bearing : Rotaci\u00f3n inicial del mapa (en grados) pitch : Inclinaci\u00f3n inicial del mapa para verlo en perspectiva (de 0 a 60 grados) Tip La especificaci\u00f3n completa del fichero de estilo es parte de la documentaci\u00f3n on-line de Mapbox GL JS . Tip Si quisi\u00e9ramos editar el fichero de estilo, basta con guardarnos una copia local junto a barcelona.html y modificar la propiedad style para apuntar a una URL relativa. Lo veremos con m\u00e1s detalle en el punto 6.","title":"Contenido de un fichero de estilo"},{"location":"3_tileserver_gl/","text":"C\u00f3mo servir teselas vectoriales Instalaci\u00f3n de TileServer GL TileServer GL es un servidor de mapas de c\u00f3digo abierto creado para teselas vectoriales, y capaz de renderizar en teselas raster con MapBox GL Native engine en el lado del servidor. Proporciona mapas para aplicaciones web y m\u00f3viles. Es compatibles con Mapbox GL JS, Android SDK, iOS SDK, Leaflet, OpenLayers, HighDPI/Retina, SIG a trav\u00e9s de WMTS, etc. Si se quiere servir teselas raster lo mejor es utilizar la versi\u00f3n de Docker ya que son necesarias algunas librer\u00edas nativas que pueden variar dependiendo de la plataforma, estas librer\u00edas sirven para renderizar las teselas vectoriales en teselas raster. Si \u00fanicamente se quiere servir teselas vectoriales se puede utilizar el TileServer GL Light, que no tiene ninguna dependencia nativa ya que est\u00e1 desarrollado en javascript. Para este taller utilizaremos la versi\u00f3n Light ya que serviremos s\u00f3lo teselas vectoriales. Es necesario tener instalado Node.js versi\u00f3n 6. Warning tileserver-gl-light NO se instalar\u00e1 correctamente si estamos usando una versi\u00f3n de Node.js superior a la 6. Debemos activar esta versi\u00f3n de node con el comando: 1 2 nvm use 6 node -v # Deber\u00eda devolver: 6.x.x Una vez comprobada la versi\u00f3n de node: 1 2 npm install -g tileserver-gl-light@2.3.1 tileserver-gl-light -v # Deberia devolver: v2.3.1 Arranque con la configuraci\u00f3n por defecto Obtener datos de Barcelona Crear una carpeta llamada tileserver/data y copiar en ella el fichero `datos/barcelona.mbtiles: 1 2 3 cd ~/Desktop/taller-vt mkdir -p tileserver/data cp datos/barcelona.mbtiles tileserver/data Tip En la web de OpenMapTiles se pueden descargar datos de muchas otras ciudades, pa\u00edses, e incluso el planeta entero. Es gratu\u00edto, aunque hay que registrarse y los datos no est\u00e1n del todo actualizados. Ahora arrancaremos el servidor en el puerto 8081 (par\u00e1metro -p ): 1 2 cd tileserver tileserver-gl-light data/barcelona.mbtiles -p 8081 Abrir el navegador y escribir http://localhost:8081 . Aparecer\u00e1 la p\u00e1gina del TileServer. Dejar el terminal abierto con el servidor arrancado. TileServer GL Light Modificar el visor de mapas Modificaremos nuestro archivo barcelona.html para que el visor de mapas consuma las teselas vectoriales servidas por nuestro TileServer: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 !DOCTYPE html html head meta charset = UTF-8 meta name = viewport content = width=device-width, initial-scale=1 title Mapa VT / title link rel = stylesheet href = https://api.tiles.mapbox.com/mapbox-gl-js/v0.44.1/mapbox-gl.css / script src = https://api.tiles.mapbox.com/mapbox-gl-js/v0.44.1/mapbox-gl.js / script link href = https://mapbox-gl-inspect.lukasmartinelli.ch/dist/mapbox-gl-inspect.css rel = stylesheet / script src = https://mapbox-gl-inspect.lukasmartinelli.ch/dist/mapbox-gl-inspect.min.js / script style html , body { margin : 0 ; height : 100 % ; } / style / head body id = map script var map = new mapboxgl . Map ({ container : map , // id del elemento HTML que contendr\u00e1 el mapa style : http://localhost:8081/styles/osm-bright/style.json , // Ubicaci\u00f3n del estilo center : [ 2.175 , 41.39 ], // Ubicaci\u00f3n inicial zoom : 13 , // Zoom inicial bearing : - 45 , // \u00c1ngulo de rotaci\u00f3n inicial hash : true // Permite ir guardando la posici\u00f3n del mapa en la URL }); // Agrega controles de navegaci\u00f3n (zoom, rotaci\u00f3n) al mapa: map . addControl ( new mapboxgl . NavigationControl ()); // Agregar el control de inspecci\u00f3n map . addControl ( new MapboxInspect ()); / script / body / html Configuraci\u00f3n completa Vamos a extraer un primer fichero de configuraci\u00f3n. Para ello, debemos parar el servidor tileserver-gl-light y vamos a arrancarlo de nuevo, pero esta vez con la opci\u00f3n -V (verbose): 1 tileserver-gl-light data/barcelona.mbtiles -p 8081 -V Observaremos que nos responde \"Automatically creating config file for barcelona.mbtiles\", y a continuaci\u00f3n nos muestra el fichero de configuraci\u00f3n que ha autogenerado, y que aproximadamente tendr\u00e1 este aspecto: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 { options : { paths : { root : /home/user/.nvm/versions/node/v6.14.2/lib/node_modules/tileserver-gl-light/node_modules/tileserver-gl-styles , fonts : fonts , styles : styles , mbtiles : /home/user/Desktop/taller-vt/tileserver/data } }, styles : { klokantech-basic : { style : klokantech-basic/style.json , tilejson : { bounds : [ -180 , -85.0511 , 180 , 85.0511 ] } }, osm-bright : { style : osm-bright/style.json , tilejson : { bounds : [ -180 , -85.0511 , 180 , 85.0511 ] } } }, data : { v3 : { mbtiles : barcelona.mbtiles } } } La configuraci\u00f3n se divide en estos tres elementos: options.paths : Rutas de donde obtener los diferentes recursos: mbtiles (datos), fonts (tambi\u00e9n llamados glyphs ), y styles . styles : Ficheros de estilos y alguna informaci\u00f3n adicional para generar el fichero auxiliar TileJSON. data : Origenes de datos. Apunta a los diferentes ficheros .mbtiles que queramos servir. Copiemos la configuraci\u00f3n que nos ha devuelto tileserver-gl-light -V en un nuevo fichero llamado tileserver/config.json . Warning Atenci\u00f3n a la ruta de options.paths , que puede variar ligeramente entre estos apuntes y la ruta en vuestra m\u00e1quina, dependiendo de la versi\u00f3n exacta de node que teng\u00e1is instalada. Tened en cuenta esta discrepancia en la ruta para las pr\u00f3ximas instrucciones. El resto de la configuraci\u00f3n deber\u00eda ser la misma. Por defecto Tileserver GL viene con dos estilos incorporados ( klokantech-basic y osm-bright ) y cuatro tipograf\u00edas ( Open Sans en sus varintes Regular , Italic , Bold y Semibold ), que se esconden en la ruta profunda indicada en options.paths.root . Vamos a copiar estos recursos en nuestro directorio de trabajo: 1 2 3 cd ~/Desktop/taller-vt/tileserver cp -r /home/user/.nvm/versions/node/v6.14.2/lib/node_modules/tileserver-gl-light/node_modules/tileserver-gl-styles/styles . cp -r /home/user/.nvm/versions/node/v6.14.2/lib/node_modules/tileserver-gl-light/node_modules/tileserver-gl-styles/fonts . Warning La ruta de instalaci\u00f3n global del tileserver-gl-light puede variar de ubicaci\u00f3n. Tener en cuenta el usuario y la versi\u00f3n de node o puede estar en /usr/local/lib/ Ejemplo. cp -r /usr/local/lib/node_modules/tileserver-gl-light/node_modules/tileserver-gl-styles/styles . Comprobemos que en ~/Desktop/taller-vt/tileserver tenemos tres directorios data , fonts y styles , y el fichero config.json . Modifiquemos ahora el fichero config.json para apuntar a nuestros recursos: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 { options : { paths : { root : , fonts : fonts , styles : styles , mbtiles : data } }, styles : { klokantech-basic : { style : klokantech-basic/style.json , tilejson : { bounds : [ 1.898 , 41.246 , 2.312 , 41.533 ] } }, osm-bright : { style : osm-bright/style.json , tilejson : { bounds : [ 1.898 , 41.246 , 2.312 , 41.533 ] } } }, data : { v3 : { mbtiles : barcelona.mbtiles } } } De paso hemos modificado el BBOX de los datos de Barcelona, que no estaba bien ajustado. Ahora paramos y arrancamos tileserver de nuevo, sin m\u00e1s par\u00e1metros que el puerto, y leer\u00e1 autom\u00e1ticamente la configuraci\u00f3n del nuevo fichero config.json : 1 tileserver-gl-light -p 8081 Tileserver deber\u00e1 decir \"Using specified config file from config.json\". Si vamos a http://localhost:8081 deber\u00edamos ver lo mismo que antes, pero ahora podremos ir a\u00f1adiendo y modificando los recursos (datos, estilos, tipograf\u00edas e iconos) que servimos. A\u00f1adiendo datos de edificios Vamos a copiar un nuevo .mbtiles con informaci\u00f3n de edificios: 1 cp ../datos/buildings.mbtiles data/ Y lo vamos a a\u00f1adir al fichero config.json : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 { options : { paths : { root : , fonts : fonts , styles : styles , mbtiles : data } }, styles : { klokantech-basic : { style : klokantech-basic/style.json , tilejson : { bounds : [ 1.898 , 41.246 , 2.312 , 41.533 ] } }, osm-bright : { style : osm-bright/style.json , tilejson : { bounds : [ 1.898 , 41.246 , 2.312 , 41.533 ] } } }, data : { v3 : { mbtiles : barcelona.mbtiles }, buildings : { mbtiles : buildings.mbtiles } } } Paramos el servidor y arrancamos de nuevo. Recargando la p\u00e1gina http://localhost:8081 veremos el nuevo dataset: Haciendo click en \"Preview\": Efectivamente, se trata de una capa con m\u00e1s de 500.000 construcciones de catastro, con la referencia de la parcela catastral a la que pertenece cada construcci\u00f3n, y el n\u00famero de plantas para cada construcci\u00f3n. Question \u00bfPara qu\u00e9 sirve el \"TileJSON\" de un dataset? En \u00faltima instancia, las teselas vectoriales se sirven en un servicio HTTP con una URL que acaba en /{z}/{x}/{y}.pbf . De hecho, en el estilo de mapbox podemos indicar esta url directamente, as\u00ed: 1 2 3 4 5 6 7 sources : { ... buildings , { type : vector , tiles : [ http://localhost:8081/data/buildings/{z}/{x}/{y}.pbf ] } } Aunque el m\u00e9todo preferido es apuntar a un TileJSON. Esta configuraci\u00f3n ser\u00eda equivalente a la anterior, pero m\u00e1s correcta: 1 2 3 4 5 6 7 sources : { ... buildings , { type : vector , url : http://localhost:8081/data/buildings.json } } El fichero TileJSON acaba teniendo una propiedad \"tiles\" que apunta al servicio XYZ, pero adem\u00e1s contiene otros metadatos \u00fatiles para quien consume el dataset. Por ejemplo, el rango de niveles de zoom v\u00e1lidos para el dataset ( minzoom , maxzoom ) y el bbox v\u00e1lido ( bounds ), lo que evita hacer peticiones fuera de rango al servidor, y otros metadatos como las \"capas\" contenidas en cada Vector Tile, y los atributos de cada capa. Esto ayuda a funcionar al InspectorPlugin , y tambi\u00e9n nos da informaci\u00f3n a la hora de simbolizar la capa, ya que nos describe el esquema de los datos. A\u00f1adiendo los nuevos datos al visor Para visualizar los datos de edificios en barcelona.html , usar el siguiente c\u00f3digo javascript: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 script var map = new mapboxgl . Map ({ container : map , // id del elemento HTML que contendr\u00e1 el mapa style : http://localhost:8081/styles/klokantech-basic/style.json , center : [ 2.19224 , 41.38585 ], zoom : 15 , bearing : - 45 , pitch : 60 , hash : true }); map . on ( load , function () { map . addSource ( buildings , { type : vector , url : http://localhost:8081/data/buildings.json }); map . addLayer ({ id : buildings , source : buildings , source-layer : buildingpart , type : fill , paint : { fill-opacity : 0.75 , fill-color : #E9DFCD , fill-outline-color : #000 } }); }); // Agrega controles de navegaci\u00f3n (zoom, rotaci\u00f3n) al mapa: map . addControl ( new mapboxgl . NavigationControl ()); // Agregar el control de inspecci\u00f3n map . addControl ( new MapboxInspect ()); / script Incluso podemos usar una regla de simbolizaci\u00f3n de extrusi\u00f3n para verlos en 3D: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 script var map = new mapboxgl . Map ({ container : map , // id del elemento HTML que contendr\u00e1 el mapa style : http://localhost:8081/styles/klokantech-basic/style.json , center : [ 2.19224 , 41.38585 ], zoom : 15 , bearing : - 45 , pitch : 60 , hash : true }); map . on ( load , function () { map . addSource ( buildings , { type : vector , url : http://localhost:8081/data/buildings.json }); map . addLayer ({ id : buildings , source : buildings , source-layer : buildingpart , type : fill-extrusion , paint : { fill-extrusion-opacity : 0.75 , fill-extrusion-color : #E9DFCD , fill-extrusion-height : [ * , 3 , [ get , floors ]] } }); }); // Agrega controles de navegaci\u00f3n (zoom, rotaci\u00f3n) al mapa: map . addControl ( new mapboxgl . NavigationControl ()); // Agregar el control de inspecci\u00f3n map . addControl ( new MapboxInspect ()); / script En la regla de simbolizaci\u00f3n hemos utilizado como altura de la extrusi\u00f3n el n\u00famero de plantas multiplicado por 3.","title":"3. C\u00f3mo servirlas"},{"location":"3_tileserver_gl/#como-servir-teselas-vectoriales","text":"","title":"C\u00f3mo servir teselas vectoriales"},{"location":"3_tileserver_gl/#instalacion-de-tileserver-gl","text":"TileServer GL es un servidor de mapas de c\u00f3digo abierto creado para teselas vectoriales, y capaz de renderizar en teselas raster con MapBox GL Native engine en el lado del servidor. Proporciona mapas para aplicaciones web y m\u00f3viles. Es compatibles con Mapbox GL JS, Android SDK, iOS SDK, Leaflet, OpenLayers, HighDPI/Retina, SIG a trav\u00e9s de WMTS, etc. Si se quiere servir teselas raster lo mejor es utilizar la versi\u00f3n de Docker ya que son necesarias algunas librer\u00edas nativas que pueden variar dependiendo de la plataforma, estas librer\u00edas sirven para renderizar las teselas vectoriales en teselas raster. Si \u00fanicamente se quiere servir teselas vectoriales se puede utilizar el TileServer GL Light, que no tiene ninguna dependencia nativa ya que est\u00e1 desarrollado en javascript. Para este taller utilizaremos la versi\u00f3n Light ya que serviremos s\u00f3lo teselas vectoriales. Es necesario tener instalado Node.js versi\u00f3n 6. Warning tileserver-gl-light NO se instalar\u00e1 correctamente si estamos usando una versi\u00f3n de Node.js superior a la 6. Debemos activar esta versi\u00f3n de node con el comando: 1 2 nvm use 6 node -v # Deber\u00eda devolver: 6.x.x Una vez comprobada la versi\u00f3n de node: 1 2 npm install -g tileserver-gl-light@2.3.1 tileserver-gl-light -v # Deberia devolver: v2.3.1","title":"Instalaci\u00f3n de TileServer GL"},{"location":"3_tileserver_gl/#arranque-con-la-configuracion-por-defecto","text":"","title":"Arranque con la configuraci\u00f3n por defecto"},{"location":"3_tileserver_gl/#obtener-datos-de-barcelona","text":"Crear una carpeta llamada tileserver/data y copiar en ella el fichero `datos/barcelona.mbtiles: 1 2 3 cd ~/Desktop/taller-vt mkdir -p tileserver/data cp datos/barcelona.mbtiles tileserver/data Tip En la web de OpenMapTiles se pueden descargar datos de muchas otras ciudades, pa\u00edses, e incluso el planeta entero. Es gratu\u00edto, aunque hay que registrarse y los datos no est\u00e1n del todo actualizados. Ahora arrancaremos el servidor en el puerto 8081 (par\u00e1metro -p ): 1 2 cd tileserver tileserver-gl-light data/barcelona.mbtiles -p 8081 Abrir el navegador y escribir http://localhost:8081 . Aparecer\u00e1 la p\u00e1gina del TileServer. Dejar el terminal abierto con el servidor arrancado. TileServer GL Light","title":"Obtener datos de Barcelona"},{"location":"3_tileserver_gl/#modificar-el-visor-de-mapas","text":"Modificaremos nuestro archivo barcelona.html para que el visor de mapas consuma las teselas vectoriales servidas por nuestro TileServer: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 !DOCTYPE html html head meta charset = UTF-8 meta name = viewport content = width=device-width, initial-scale=1 title Mapa VT / title link rel = stylesheet href = https://api.tiles.mapbox.com/mapbox-gl-js/v0.44.1/mapbox-gl.css / script src = https://api.tiles.mapbox.com/mapbox-gl-js/v0.44.1/mapbox-gl.js / script link href = https://mapbox-gl-inspect.lukasmartinelli.ch/dist/mapbox-gl-inspect.css rel = stylesheet / script src = https://mapbox-gl-inspect.lukasmartinelli.ch/dist/mapbox-gl-inspect.min.js / script style html , body { margin : 0 ; height : 100 % ; } / style / head body id = map script var map = new mapboxgl . Map ({ container : map , // id del elemento HTML que contendr\u00e1 el mapa style : http://localhost:8081/styles/osm-bright/style.json , // Ubicaci\u00f3n del estilo center : [ 2.175 , 41.39 ], // Ubicaci\u00f3n inicial zoom : 13 , // Zoom inicial bearing : - 45 , // \u00c1ngulo de rotaci\u00f3n inicial hash : true // Permite ir guardando la posici\u00f3n del mapa en la URL }); // Agrega controles de navegaci\u00f3n (zoom, rotaci\u00f3n) al mapa: map . addControl ( new mapboxgl . NavigationControl ()); // Agregar el control de inspecci\u00f3n map . addControl ( new MapboxInspect ()); / script / body / html","title":"Modificar el visor de mapas"},{"location":"3_tileserver_gl/#configuracion-completa","text":"Vamos a extraer un primer fichero de configuraci\u00f3n. Para ello, debemos parar el servidor tileserver-gl-light y vamos a arrancarlo de nuevo, pero esta vez con la opci\u00f3n -V (verbose): 1 tileserver-gl-light data/barcelona.mbtiles -p 8081 -V Observaremos que nos responde \"Automatically creating config file for barcelona.mbtiles\", y a continuaci\u00f3n nos muestra el fichero de configuraci\u00f3n que ha autogenerado, y que aproximadamente tendr\u00e1 este aspecto: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 { options : { paths : { root : /home/user/.nvm/versions/node/v6.14.2/lib/node_modules/tileserver-gl-light/node_modules/tileserver-gl-styles , fonts : fonts , styles : styles , mbtiles : /home/user/Desktop/taller-vt/tileserver/data } }, styles : { klokantech-basic : { style : klokantech-basic/style.json , tilejson : { bounds : [ -180 , -85.0511 , 180 , 85.0511 ] } }, osm-bright : { style : osm-bright/style.json , tilejson : { bounds : [ -180 , -85.0511 , 180 , 85.0511 ] } } }, data : { v3 : { mbtiles : barcelona.mbtiles } } } La configuraci\u00f3n se divide en estos tres elementos: options.paths : Rutas de donde obtener los diferentes recursos: mbtiles (datos), fonts (tambi\u00e9n llamados glyphs ), y styles . styles : Ficheros de estilos y alguna informaci\u00f3n adicional para generar el fichero auxiliar TileJSON. data : Origenes de datos. Apunta a los diferentes ficheros .mbtiles que queramos servir. Copiemos la configuraci\u00f3n que nos ha devuelto tileserver-gl-light -V en un nuevo fichero llamado tileserver/config.json . Warning Atenci\u00f3n a la ruta de options.paths , que puede variar ligeramente entre estos apuntes y la ruta en vuestra m\u00e1quina, dependiendo de la versi\u00f3n exacta de node que teng\u00e1is instalada. Tened en cuenta esta discrepancia en la ruta para las pr\u00f3ximas instrucciones. El resto de la configuraci\u00f3n deber\u00eda ser la misma. Por defecto Tileserver GL viene con dos estilos incorporados ( klokantech-basic y osm-bright ) y cuatro tipograf\u00edas ( Open Sans en sus varintes Regular , Italic , Bold y Semibold ), que se esconden en la ruta profunda indicada en options.paths.root . Vamos a copiar estos recursos en nuestro directorio de trabajo: 1 2 3 cd ~/Desktop/taller-vt/tileserver cp -r /home/user/.nvm/versions/node/v6.14.2/lib/node_modules/tileserver-gl-light/node_modules/tileserver-gl-styles/styles . cp -r /home/user/.nvm/versions/node/v6.14.2/lib/node_modules/tileserver-gl-light/node_modules/tileserver-gl-styles/fonts . Warning La ruta de instalaci\u00f3n global del tileserver-gl-light puede variar de ubicaci\u00f3n. Tener en cuenta el usuario y la versi\u00f3n de node o puede estar en /usr/local/lib/ Ejemplo. cp -r /usr/local/lib/node_modules/tileserver-gl-light/node_modules/tileserver-gl-styles/styles . Comprobemos que en ~/Desktop/taller-vt/tileserver tenemos tres directorios data , fonts y styles , y el fichero config.json . Modifiquemos ahora el fichero config.json para apuntar a nuestros recursos: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 { options : { paths : { root : , fonts : fonts , styles : styles , mbtiles : data } }, styles : { klokantech-basic : { style : klokantech-basic/style.json , tilejson : { bounds : [ 1.898 , 41.246 , 2.312 , 41.533 ] } }, osm-bright : { style : osm-bright/style.json , tilejson : { bounds : [ 1.898 , 41.246 , 2.312 , 41.533 ] } } }, data : { v3 : { mbtiles : barcelona.mbtiles } } } De paso hemos modificado el BBOX de los datos de Barcelona, que no estaba bien ajustado. Ahora paramos y arrancamos tileserver de nuevo, sin m\u00e1s par\u00e1metros que el puerto, y leer\u00e1 autom\u00e1ticamente la configuraci\u00f3n del nuevo fichero config.json : 1 tileserver-gl-light -p 8081 Tileserver deber\u00e1 decir \"Using specified config file from config.json\". Si vamos a http://localhost:8081 deber\u00edamos ver lo mismo que antes, pero ahora podremos ir a\u00f1adiendo y modificando los recursos (datos, estilos, tipograf\u00edas e iconos) que servimos.","title":"Configuraci\u00f3n completa"},{"location":"3_tileserver_gl/#anadiendo-datos-de-edificios","text":"Vamos a copiar un nuevo .mbtiles con informaci\u00f3n de edificios: 1 cp ../datos/buildings.mbtiles data/ Y lo vamos a a\u00f1adir al fichero config.json : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 { options : { paths : { root : , fonts : fonts , styles : styles , mbtiles : data } }, styles : { klokantech-basic : { style : klokantech-basic/style.json , tilejson : { bounds : [ 1.898 , 41.246 , 2.312 , 41.533 ] } }, osm-bright : { style : osm-bright/style.json , tilejson : { bounds : [ 1.898 , 41.246 , 2.312 , 41.533 ] } } }, data : { v3 : { mbtiles : barcelona.mbtiles }, buildings : { mbtiles : buildings.mbtiles } } } Paramos el servidor y arrancamos de nuevo. Recargando la p\u00e1gina http://localhost:8081 veremos el nuevo dataset: Haciendo click en \"Preview\": Efectivamente, se trata de una capa con m\u00e1s de 500.000 construcciones de catastro, con la referencia de la parcela catastral a la que pertenece cada construcci\u00f3n, y el n\u00famero de plantas para cada construcci\u00f3n. Question \u00bfPara qu\u00e9 sirve el \"TileJSON\" de un dataset? En \u00faltima instancia, las teselas vectoriales se sirven en un servicio HTTP con una URL que acaba en /{z}/{x}/{y}.pbf . De hecho, en el estilo de mapbox podemos indicar esta url directamente, as\u00ed: 1 2 3 4 5 6 7 sources : { ... buildings , { type : vector , tiles : [ http://localhost:8081/data/buildings/{z}/{x}/{y}.pbf ] } } Aunque el m\u00e9todo preferido es apuntar a un TileJSON. Esta configuraci\u00f3n ser\u00eda equivalente a la anterior, pero m\u00e1s correcta: 1 2 3 4 5 6 7 sources : { ... buildings , { type : vector , url : http://localhost:8081/data/buildings.json } } El fichero TileJSON acaba teniendo una propiedad \"tiles\" que apunta al servicio XYZ, pero adem\u00e1s contiene otros metadatos \u00fatiles para quien consume el dataset. Por ejemplo, el rango de niveles de zoom v\u00e1lidos para el dataset ( minzoom , maxzoom ) y el bbox v\u00e1lido ( bounds ), lo que evita hacer peticiones fuera de rango al servidor, y otros metadatos como las \"capas\" contenidas en cada Vector Tile, y los atributos de cada capa. Esto ayuda a funcionar al InspectorPlugin , y tambi\u00e9n nos da informaci\u00f3n a la hora de simbolizar la capa, ya que nos describe el esquema de los datos.","title":"A\u00f1adiendo datos de edificios"},{"location":"3_tileserver_gl/#anadiendo-los-nuevos-datos-al-visor","text":"Para visualizar los datos de edificios en barcelona.html , usar el siguiente c\u00f3digo javascript: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 script var map = new mapboxgl . Map ({ container : map , // id del elemento HTML que contendr\u00e1 el mapa style : http://localhost:8081/styles/klokantech-basic/style.json , center : [ 2.19224 , 41.38585 ], zoom : 15 , bearing : - 45 , pitch : 60 , hash : true }); map . on ( load , function () { map . addSource ( buildings , { type : vector , url : http://localhost:8081/data/buildings.json }); map . addLayer ({ id : buildings , source : buildings , source-layer : buildingpart , type : fill , paint : { fill-opacity : 0.75 , fill-color : #E9DFCD , fill-outline-color : #000 } }); }); // Agrega controles de navegaci\u00f3n (zoom, rotaci\u00f3n) al mapa: map . addControl ( new mapboxgl . NavigationControl ()); // Agregar el control de inspecci\u00f3n map . addControl ( new MapboxInspect ()); / script Incluso podemos usar una regla de simbolizaci\u00f3n de extrusi\u00f3n para verlos en 3D: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 script var map = new mapboxgl . Map ({ container : map , // id del elemento HTML que contendr\u00e1 el mapa style : http://localhost:8081/styles/klokantech-basic/style.json , center : [ 2.19224 , 41.38585 ], zoom : 15 , bearing : - 45 , pitch : 60 , hash : true }); map . on ( load , function () { map . addSource ( buildings , { type : vector , url : http://localhost:8081/data/buildings.json }); map . addLayer ({ id : buildings , source : buildings , source-layer : buildingpart , type : fill-extrusion , paint : { fill-extrusion-opacity : 0.75 , fill-extrusion-color : #E9DFCD , fill-extrusion-height : [ * , 3 , [ get , floors ]] } }); }); // Agrega controles de navegaci\u00f3n (zoom, rotaci\u00f3n) al mapa: map . addControl ( new mapboxgl . NavigationControl ()); // Agregar el control de inspecci\u00f3n map . addControl ( new MapboxInspect ()); / script En la regla de simbolizaci\u00f3n hemos utilizado como altura de la extrusi\u00f3n el n\u00famero de plantas multiplicado por 3.","title":"A\u00f1adiendo los nuevos datos al visor"},{"location":"4_tippecanoe/","text":"C\u00f3mo crear teselas vectoriales Los datos de Natural Earth En el apartado de descargas de Natural Earth hay varios conjuntos de datos en formato Shapefile, seg\u00fan la escala. En el taller trabajaremos con un subconjunto de los datos de la escala 1:10M (1:10.000.000). Para ahorrarnos la transformaci\u00f3n de Shapefile a GeoJSON, utilizaremos los datos procedentes de https://github.com/nvkelso/natural-earth-vector/ . En concreto usaremos las siguientes capas: Cultural Admin 0 \u2013 Countries (247 pa\u00edses en el mundo. Groenlandia separada de Dinamarca) Populated Places (Puntos de ciudades y pueblos) Roads (Carreteras principales) Railroads (V\u00edas de Trenes) Airports (Aeropuertos) Physical Coastline (L\u00ednea de costa que incluyen islas principales) Land (Pol\u00edgonos terrestres que incluyen islas principales) Ocean (Oceano) Rivers + lake centerlines (Rios en \u00fanica l\u00ednea que incluyen l\u00edneas centrales de lagos) Lakes + Reservoirs (Lagos naturales y artificiales) Nosotros descargaremos las 10 capas de un zip y las descomprimiremos en taller-vt/datos/naturalearth : 1 2 3 cd ~/Desktop/taller-vt/datos wget https://geoinquiets.github.io/taller-vt/downloads/naturalearth.zip unzip naturalearth.zip Tippecanoe Tippecanoe es la herramienta que permite crear teselas vectoriales de grandes colecciones de elementos en formato GeoJSON. El objetivo de Tippecanoe es permitir una visi\u00f3n de sus datos independiente de la escala, de modo que en cualquier nivel, desde el mundo entero hasta un solo edificio, se pueda apreciar la densidad y la textura de los datos, en lugar de una simplificaci\u00f3n geom\u00e9trica, que puede eliminar v\u00e9rtices importantes que cambien la apariencia de los datos en su versi\u00f3n simplificada. Algunos ejemplos: Teniendo todo el callejero de OpenStreetMap, la vista general devolver\u00e1 algo que se parece a \"Todas las calles\" en lugar de algo que parece un atlas de carreteras interestatal. Teniendo todas las plantas de edificios de una ciudad, en la vista general donde los edificios individuales ya no sean perceptibles, a\u00fan deber\u00edas poder ver la extensi\u00f3n y variedad del desarrollo en cada vecindario, no solo para los edificios m\u00e1s voluminosos. Esto hace que la calidad de los resultados de Tippecanoe sea muy superior a otras alternativas, que utilizan algoritmos de simplificaci\u00f3n m\u00e1s convencionales, motivo por el cual lo recomendamos en este taller. Adem\u00e1s, es sorprendentemente r\u00e1pido procesando los datos. Creando el fichero mbtiles Vamos a crear un fichero mbtiles llamado natural_earth.mbtiles que contendr\u00e1 nuestras 10 capas. Para crear el mbtiles utilizaremos las siguientes opciones del Tippecanoe : -o nombre.mbtiles : nombre del archivo de salida. -zg : Estima un maxzoom razonable basado en la resoluci\u00f3n de los datos. --drop-densest-as-needed : Si una tesela es demasiado pesada, intenta reducirla a menos de 500 KB reduciendo su detalle. -L nombre:archivo.json : permite definir nombres de capa para cada archivo individual. Para generar el archivo mbtiles escribiremos lo siguiente en el terminal: 1 2 3 4 5 6 7 8 9 10 11 12 cd naturalearth tippecanoe -o natural_earth.mbtiles -zg --drop-densest-as-needed \\ -L ocean:ne_10m_ocean.geojson \\ -L land:ne_10m_land.geojson \\ -L admin:ne_10m_admin_0_countries.geojson \\ -L coastline:ne_10m_coastline.geojson \\ -L lakes:ne_10m_lakes.geojson \\ -L rivers:ne_10m_rivers_lake_centerlines.geojson \\ -L rail:ne_10m_railroads.geojson \\ -L roads:ne_10m_roads.geojson \\ -L cities:ne_10m_populated_places.geojson \\ -L airports:ne_10m_airports.geojson Publicando el mbtiles A\u00f1adiremos el mbtiles a Tileserver GL igual que hicimos con los edificios de Barcelona: 1 2 mv natural_earth.mbtiles ../../tileserver/data cd ../../tileserver Editamos config.json y a\u00f1adimos la nueva capa: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 { ... data : { v3 : { mbtiles : barcelona.mbtiles }, buildings : { mbtiles : buildings.mbtiles }, natural_earth : { mbtiles : natural_earth.mbtiles } } } Tras parar y arrancar el tileserver de nuevo, abrir el navegador y escribir http://localhost:8081 y comprobar que aparece la p\u00e1gina del TileServer con nuestro mbtiles: Hacer click en el bot\u00f3n de Inspect y comprobar que en el mapa aparecen todas las capas agregadas al mbtiles: As\u00ed pues, una tesela vectorial contiene varias \"capas\" internamente. En una regla de simbolizaci\u00f3n, deber\u00e1 indicarse tanto origen de datos ( \"source\": \"natural_earth\" ), como la capa dentro de la tesela ( \"source_layer\": \"roads\" ).","title":"4. C\u00f3mo crearlas"},{"location":"4_tippecanoe/#como-crear-teselas-vectoriales","text":"","title":"C\u00f3mo crear teselas vectoriales"},{"location":"4_tippecanoe/#los-datos-de-natural-earth","text":"En el apartado de descargas de Natural Earth hay varios conjuntos de datos en formato Shapefile, seg\u00fan la escala. En el taller trabajaremos con un subconjunto de los datos de la escala 1:10M (1:10.000.000). Para ahorrarnos la transformaci\u00f3n de Shapefile a GeoJSON, utilizaremos los datos procedentes de https://github.com/nvkelso/natural-earth-vector/ . En concreto usaremos las siguientes capas: Cultural Admin 0 \u2013 Countries (247 pa\u00edses en el mundo. Groenlandia separada de Dinamarca) Populated Places (Puntos de ciudades y pueblos) Roads (Carreteras principales) Railroads (V\u00edas de Trenes) Airports (Aeropuertos) Physical Coastline (L\u00ednea de costa que incluyen islas principales) Land (Pol\u00edgonos terrestres que incluyen islas principales) Ocean (Oceano) Rivers + lake centerlines (Rios en \u00fanica l\u00ednea que incluyen l\u00edneas centrales de lagos) Lakes + Reservoirs (Lagos naturales y artificiales) Nosotros descargaremos las 10 capas de un zip y las descomprimiremos en taller-vt/datos/naturalearth : 1 2 3 cd ~/Desktop/taller-vt/datos wget https://geoinquiets.github.io/taller-vt/downloads/naturalearth.zip unzip naturalearth.zip","title":"Los datos de Natural Earth"},{"location":"4_tippecanoe/#tippecanoe","text":"Tippecanoe es la herramienta que permite crear teselas vectoriales de grandes colecciones de elementos en formato GeoJSON. El objetivo de Tippecanoe es permitir una visi\u00f3n de sus datos independiente de la escala, de modo que en cualquier nivel, desde el mundo entero hasta un solo edificio, se pueda apreciar la densidad y la textura de los datos, en lugar de una simplificaci\u00f3n geom\u00e9trica, que puede eliminar v\u00e9rtices importantes que cambien la apariencia de los datos en su versi\u00f3n simplificada. Algunos ejemplos: Teniendo todo el callejero de OpenStreetMap, la vista general devolver\u00e1 algo que se parece a \"Todas las calles\" en lugar de algo que parece un atlas de carreteras interestatal. Teniendo todas las plantas de edificios de una ciudad, en la vista general donde los edificios individuales ya no sean perceptibles, a\u00fan deber\u00edas poder ver la extensi\u00f3n y variedad del desarrollo en cada vecindario, no solo para los edificios m\u00e1s voluminosos. Esto hace que la calidad de los resultados de Tippecanoe sea muy superior a otras alternativas, que utilizan algoritmos de simplificaci\u00f3n m\u00e1s convencionales, motivo por el cual lo recomendamos en este taller. Adem\u00e1s, es sorprendentemente r\u00e1pido procesando los datos.","title":"Tippecanoe"},{"location":"4_tippecanoe/#creando-el-fichero-mbtiles","text":"Vamos a crear un fichero mbtiles llamado natural_earth.mbtiles que contendr\u00e1 nuestras 10 capas. Para crear el mbtiles utilizaremos las siguientes opciones del Tippecanoe : -o nombre.mbtiles : nombre del archivo de salida. -zg : Estima un maxzoom razonable basado en la resoluci\u00f3n de los datos. --drop-densest-as-needed : Si una tesela es demasiado pesada, intenta reducirla a menos de 500 KB reduciendo su detalle. -L nombre:archivo.json : permite definir nombres de capa para cada archivo individual. Para generar el archivo mbtiles escribiremos lo siguiente en el terminal: 1 2 3 4 5 6 7 8 9 10 11 12 cd naturalearth tippecanoe -o natural_earth.mbtiles -zg --drop-densest-as-needed \\ -L ocean:ne_10m_ocean.geojson \\ -L land:ne_10m_land.geojson \\ -L admin:ne_10m_admin_0_countries.geojson \\ -L coastline:ne_10m_coastline.geojson \\ -L lakes:ne_10m_lakes.geojson \\ -L rivers:ne_10m_rivers_lake_centerlines.geojson \\ -L rail:ne_10m_railroads.geojson \\ -L roads:ne_10m_roads.geojson \\ -L cities:ne_10m_populated_places.geojson \\ -L airports:ne_10m_airports.geojson","title":"Creando el fichero mbtiles"},{"location":"4_tippecanoe/#publicando-el-mbtiles","text":"A\u00f1adiremos el mbtiles a Tileserver GL igual que hicimos con los edificios de Barcelona: 1 2 mv natural_earth.mbtiles ../../tileserver/data cd ../../tileserver Editamos config.json y a\u00f1adimos la nueva capa: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 { ... data : { v3 : { mbtiles : barcelona.mbtiles }, buildings : { mbtiles : buildings.mbtiles }, natural_earth : { mbtiles : natural_earth.mbtiles } } } Tras parar y arrancar el tileserver de nuevo, abrir el navegador y escribir http://localhost:8081 y comprobar que aparece la p\u00e1gina del TileServer con nuestro mbtiles: Hacer click en el bot\u00f3n de Inspect y comprobar que en el mapa aparecen todas las capas agregadas al mbtiles: As\u00ed pues, una tesela vectorial contiene varias \"capas\" internamente. En una regla de simbolizaci\u00f3n, deber\u00e1 indicarse tanto origen de datos ( \"source\": \"natural_earth\" ), como la capa dentro de la tesela ( \"source_layer\": \"roads\" ).","title":"Publicando el mbtiles"},{"location":"5_sprites_glyphs/","text":"Sprites y Glyphs Sprites Definici\u00f3n Un sprite es una imagen individual que contiene todos los iconos incluidos en un estilo. Al combinar muchas im\u00e1genes peque\u00f1as en una sola imagen (sprite), se puede reducir el n\u00famero de solicitudes necesarias para recuperar todas las im\u00e1genes, mejorar el rendimiento y hacer que el mapa sea m\u00e1s r\u00e1pido. Los Sprites pueden tener un tama\u00f1o m\u00e1ximo de 1024x1024 p\u00edxeles (o 2048x2048 para pantallas con alta DPI). Cada sprite viene acompa\u00f1ado de un archivo JSON donde se define el nombre de cada icono, y su posici\u00f3n y tama\u00f1o para saber c\u00f3mo \"recortarlo\" de la imagen com\u00fan. M\u00e1s informaci\u00f3n en sobre sprites https://www.mapbox.com/help/define-sprite/ Cada uno de los iconos contenidos en un sprite se puede usar como textura para el fondo del mapa, patr\u00f3n de relleno para un pol\u00edgono, patr\u00f3n de dibujo para una l\u00ednea, o una imagen de icono (s\u00edmbolo puntual). La propiedad sprite de un estilo apunta a una URL incompleta , a partir de la cual se pueden encontrar los diferentes ficheros (sprites y json complementario). Por ejemplo, si en el style.json se indica: 1 2 3 4 { ... sprite : http://localhost:8081/styles/osm-bright/sprite } En realidad dicha URL no existe. Pero s\u00ed existen los siguientes recursos (a\u00f1adiendo .png , .json , @2x.png y @2x.json respectivamente): http://localhost:8081/styles/osm-bright/sprite.png Sprite a resoluci\u00f3n convencional http://localhost:8081/styles/osm-bright/sprite.json JSON que define cada icono dentro del sprite http://localhost:8081/styles/osm-bright/sprite@2x.png Sprite a resoluci\u00f3n doble (para pantallas Retina) http://localhost:8081/styles/osm-bright/sprite@2x.json JSON que define cada icono dentro del sprite de resoluci\u00f3n doble Ejemplo de sprite: Uno de los elementos definidos en el JSON: 1 2 3 4 5 6 7 8 9 10 11 { ... airport_11 : { height : 17 , width : 17 , x : 17 , y : 0 , pixelRatio : 1 }, .... } C\u00f3mo crear tus propios sprites Para generar los sprites a partir de im\u00e1genes individuales hay que crear los cuatro archivos. Esto se podr\u00eda hacer manualmente con un editor de texto, un editor de im\u00e1genes y mucha paciencia, pero afortunadamente existen herramientas que lo automatizan. Los sprites convencionales para la web difieren de los de Mapbox, ya que utilizan una imagen compuesta png y un archivo css con las reglas de simbolizaci\u00f3n para su aprovechamiento en p\u00e1ginas web. Mapbox GL, en cambio, necesita el fichero json , no un CSS. Para generar los sprites y sus json a partir de una colecci\u00f3n de im\u00e1genes en formato SVG, se recomienda el uso de la librer\u00eda de Mapbox spritezero-cli , de la siguiente manera: 1 2 3 4 cd ~/Desktop/taller-vt/datos npm install -g @mapbox/spritezero-cli spritezero sprite iconos-maki-svg spritezero --retina sprite@2x iconos-maki-svg Una vez generados, los movemos al directorio donde residir\u00e1 el estilo que los use (en nuestro caso, natural-earth ): 1 2 mkdir ../tileserver/styles/natural-earth mv sprite* ../tileserver/styles/natural-earth Glyphs En la propiedad glyphs se indica una plantilla de URL para cargar glyphs codificados en PBF (el formato es distinto que MVT, ya que el .proto utilizado es distinto), que se usar\u00e1n para dibujar textos en el mapa. Por ejemplo: 1 2 3 4 { ... glyphs : http://localhost:8081/fonts/{fontstack}/{range}.pbf } Esta plantilla de URL debe incluir dos tokens: {fontstack} es el nombre de la tipograf\u00eda. Por ejemplo Open Sans Bold . {range} es un rango de 256 puntos de c\u00f3digo Unicode (es decir, un subconjunto de letras o s\u00edmbolos). En funci\u00f3n del texto a mostrar, el visor solicitar\u00e1 los rangos necesarios. El primero es 0-255 . Una petici\u00f3n real tendr\u00eda la forma: http://localhost:8081/fonts/Open%20Sans%20Bold/0-255.pbf Un glyph contiene una derivada de la tipograf\u00eda binaria llamada signed distance field que permite escalarla sin el pixelado. Una composici\u00f3n de varios glyphs dar\u00eda una imagen con este aspecto: C\u00f3mo crear tus propios glyphs Descargar el proyecto de github openmaptiles/fonts 1 2 3 4 5 6 cd ~/Desktop/taller-vt/ wget https://github.com/openmaptiles/fonts/archive/master.zip unzip master.zip cd fonts-master npm install node generate.js Al cabo de un rato, podemos ver los resultados en el directorio _output . Si no queremos generar una tipograf\u00eda determinada, basta con borrar el directorio que la contiene. Del mismo modo podemos a\u00f1adir tipograf\u00edas a\u00f1adiendo nuevos directorios y copiando dentro las tipograf\u00edas en formato TTF. Por ejemplo, para generar \"Comic Sans\": 1 2 3 rm -rf metropolis noto-sans open-sans pt-sans roboto cp -r ../datos/comic-sans-ms . node generate.js El directorio _output no se borra entre ejecuciones, con lo que habremos conservado todas las fuentes anteriores, adem\u00e1s de la reci\u00e9n generada \"Comic Sans\". Finalmente, copiaremos el contenido de _output al directorio tileserver/fonts : 1 \\c p -r _output/* ../tileserver/fonts Para que el tileserver publique estos recursos, hay que a\u00f1adir una propiedad a tileserver/config.json : 1 2 3 4 5 6 7 8 9 10 11 12 { options : { paths : { root : , fonts : fonts , styles : styles , mbtiles : data }, serveAllFonts : true }, ... } Reiniciando el tileserver para que cargue las nuevas tipograf\u00edas, podemos ver la lista de las tipograf\u00edas disponibles en la direcci\u00f3n http://localhost:8081/fonts.json Ejercicio extra: Generar una tipograf\u00eda a partir de un conjunto de iconos en SVG Si queremos disponer de una colecci\u00f3n de iconos monocrom\u00e1ticos de forma m\u00e1s flexible que usando sprites, los podemos convertir en una tipograf\u00eda. Esto permitir\u00e1 aplicar las t\u00e9cnicas de las etiquetas de texto a nuestros s\u00edmbolos, como escalarlos sin apreciar pixelado, cambiar su color de base, a\u00f1adir un halo, etc. Para transformar un conjunto de iconos SVG en una fuente se pueden utilizar diferentes programas. Aqui un listado de algunas webs que permiten generar fuentes: https://icomoon.io http://fontello.com/ https://glyphter.com/ http://fontastic.me/ Tambi\u00e9n podemos generar una fuente propia utilizando el repositorio https://github.com/gencat/ICGC-fonticon-generator , de la siguiente manera: 1 2 3 4 5 6 cd ~/Desktop/taller-vt git clone https://github.com/gencat/ICGC-fonticon-generator npm i -g gulp cd ICGC-fonticon-generator/ npm install gulp iconfont Una vez generada la fuente, que encontraremos en iconfont/Geostart-Regular.ttf , podemos generar los glyphs como se ha explicado en el apartado anterior, y a\u00f1adirlos al tileserver.","title":"5. Sprites y Glyphs"},{"location":"5_sprites_glyphs/#sprites-y-glyphs","text":"","title":"Sprites y Glyphs"},{"location":"5_sprites_glyphs/#sprites","text":"Definici\u00f3n Un sprite es una imagen individual que contiene todos los iconos incluidos en un estilo. Al combinar muchas im\u00e1genes peque\u00f1as en una sola imagen (sprite), se puede reducir el n\u00famero de solicitudes necesarias para recuperar todas las im\u00e1genes, mejorar el rendimiento y hacer que el mapa sea m\u00e1s r\u00e1pido. Los Sprites pueden tener un tama\u00f1o m\u00e1ximo de 1024x1024 p\u00edxeles (o 2048x2048 para pantallas con alta DPI). Cada sprite viene acompa\u00f1ado de un archivo JSON donde se define el nombre de cada icono, y su posici\u00f3n y tama\u00f1o para saber c\u00f3mo \"recortarlo\" de la imagen com\u00fan. M\u00e1s informaci\u00f3n en sobre sprites https://www.mapbox.com/help/define-sprite/ Cada uno de los iconos contenidos en un sprite se puede usar como textura para el fondo del mapa, patr\u00f3n de relleno para un pol\u00edgono, patr\u00f3n de dibujo para una l\u00ednea, o una imagen de icono (s\u00edmbolo puntual). La propiedad sprite de un estilo apunta a una URL incompleta , a partir de la cual se pueden encontrar los diferentes ficheros (sprites y json complementario). Por ejemplo, si en el style.json se indica: 1 2 3 4 { ... sprite : http://localhost:8081/styles/osm-bright/sprite } En realidad dicha URL no existe. Pero s\u00ed existen los siguientes recursos (a\u00f1adiendo .png , .json , @2x.png y @2x.json respectivamente): http://localhost:8081/styles/osm-bright/sprite.png Sprite a resoluci\u00f3n convencional http://localhost:8081/styles/osm-bright/sprite.json JSON que define cada icono dentro del sprite http://localhost:8081/styles/osm-bright/sprite@2x.png Sprite a resoluci\u00f3n doble (para pantallas Retina) http://localhost:8081/styles/osm-bright/sprite@2x.json JSON que define cada icono dentro del sprite de resoluci\u00f3n doble Ejemplo de sprite: Uno de los elementos definidos en el JSON: 1 2 3 4 5 6 7 8 9 10 11 { ... airport_11 : { height : 17 , width : 17 , x : 17 , y : 0 , pixelRatio : 1 }, .... }","title":"Sprites"},{"location":"5_sprites_glyphs/#como-crear-tus-propios-sprites","text":"Para generar los sprites a partir de im\u00e1genes individuales hay que crear los cuatro archivos. Esto se podr\u00eda hacer manualmente con un editor de texto, un editor de im\u00e1genes y mucha paciencia, pero afortunadamente existen herramientas que lo automatizan. Los sprites convencionales para la web difieren de los de Mapbox, ya que utilizan una imagen compuesta png y un archivo css con las reglas de simbolizaci\u00f3n para su aprovechamiento en p\u00e1ginas web. Mapbox GL, en cambio, necesita el fichero json , no un CSS. Para generar los sprites y sus json a partir de una colecci\u00f3n de im\u00e1genes en formato SVG, se recomienda el uso de la librer\u00eda de Mapbox spritezero-cli , de la siguiente manera: 1 2 3 4 cd ~/Desktop/taller-vt/datos npm install -g @mapbox/spritezero-cli spritezero sprite iconos-maki-svg spritezero --retina sprite@2x iconos-maki-svg Una vez generados, los movemos al directorio donde residir\u00e1 el estilo que los use (en nuestro caso, natural-earth ): 1 2 mkdir ../tileserver/styles/natural-earth mv sprite* ../tileserver/styles/natural-earth","title":"C\u00f3mo crear tus propios sprites"},{"location":"5_sprites_glyphs/#glyphs","text":"En la propiedad glyphs se indica una plantilla de URL para cargar glyphs codificados en PBF (el formato es distinto que MVT, ya que el .proto utilizado es distinto), que se usar\u00e1n para dibujar textos en el mapa. Por ejemplo: 1 2 3 4 { ... glyphs : http://localhost:8081/fonts/{fontstack}/{range}.pbf } Esta plantilla de URL debe incluir dos tokens: {fontstack} es el nombre de la tipograf\u00eda. Por ejemplo Open Sans Bold . {range} es un rango de 256 puntos de c\u00f3digo Unicode (es decir, un subconjunto de letras o s\u00edmbolos). En funci\u00f3n del texto a mostrar, el visor solicitar\u00e1 los rangos necesarios. El primero es 0-255 . Una petici\u00f3n real tendr\u00eda la forma: http://localhost:8081/fonts/Open%20Sans%20Bold/0-255.pbf Un glyph contiene una derivada de la tipograf\u00eda binaria llamada signed distance field que permite escalarla sin el pixelado. Una composici\u00f3n de varios glyphs dar\u00eda una imagen con este aspecto:","title":"Glyphs"},{"location":"5_sprites_glyphs/#como-crear-tus-propios-glyphs","text":"Descargar el proyecto de github openmaptiles/fonts 1 2 3 4 5 6 cd ~/Desktop/taller-vt/ wget https://github.com/openmaptiles/fonts/archive/master.zip unzip master.zip cd fonts-master npm install node generate.js Al cabo de un rato, podemos ver los resultados en el directorio _output . Si no queremos generar una tipograf\u00eda determinada, basta con borrar el directorio que la contiene. Del mismo modo podemos a\u00f1adir tipograf\u00edas a\u00f1adiendo nuevos directorios y copiando dentro las tipograf\u00edas en formato TTF. Por ejemplo, para generar \"Comic Sans\": 1 2 3 rm -rf metropolis noto-sans open-sans pt-sans roboto cp -r ../datos/comic-sans-ms . node generate.js El directorio _output no se borra entre ejecuciones, con lo que habremos conservado todas las fuentes anteriores, adem\u00e1s de la reci\u00e9n generada \"Comic Sans\". Finalmente, copiaremos el contenido de _output al directorio tileserver/fonts : 1 \\c p -r _output/* ../tileserver/fonts Para que el tileserver publique estos recursos, hay que a\u00f1adir una propiedad a tileserver/config.json : 1 2 3 4 5 6 7 8 9 10 11 12 { options : { paths : { root : , fonts : fonts , styles : styles , mbtiles : data }, serveAllFonts : true }, ... } Reiniciando el tileserver para que cargue las nuevas tipograf\u00edas, podemos ver la lista de las tipograf\u00edas disponibles en la direcci\u00f3n http://localhost:8081/fonts.json","title":"C\u00f3mo crear tus propios glyphs"},{"location":"5_sprites_glyphs/#ejercicio-extra-generar-una-tipografia-a-partir-de-un-conjunto-de-iconos-en-svg","text":"Si queremos disponer de una colecci\u00f3n de iconos monocrom\u00e1ticos de forma m\u00e1s flexible que usando sprites, los podemos convertir en una tipograf\u00eda. Esto permitir\u00e1 aplicar las t\u00e9cnicas de las etiquetas de texto a nuestros s\u00edmbolos, como escalarlos sin apreciar pixelado, cambiar su color de base, a\u00f1adir un halo, etc. Para transformar un conjunto de iconos SVG en una fuente se pueden utilizar diferentes programas. Aqui un listado de algunas webs que permiten generar fuentes: https://icomoon.io http://fontello.com/ https://glyphter.com/ http://fontastic.me/ Tambi\u00e9n podemos generar una fuente propia utilizando el repositorio https://github.com/gencat/ICGC-fonticon-generator , de la siguiente manera: 1 2 3 4 5 6 cd ~/Desktop/taller-vt git clone https://github.com/gencat/ICGC-fonticon-generator npm i -g gulp cd ICGC-fonticon-generator/ npm install gulp iconfont Una vez generada la fuente, que encontraremos en iconfont/Geostart-Regular.ttf , podemos generar los glyphs como se ha explicado en el apartado anterior, y a\u00f1adirlos al tileserver.","title":"Ejercicio extra: Generar una tipograf\u00eda a partir de un conjunto de iconos en SVG"},{"location":"6_estilos/","text":"C\u00f3mo simbolizar teselas vectoriales Maputnik Es un editor visual gratuito y abierto para estilos Mapbox GL dirigidos tanto a desarrolladores como a dise\u00f1adores de mapas. Se puede utilizar en l\u00ednea en Maputnik editor o se puede hacer una instalaci\u00f3n local. Instalaci\u00f3n Se puede descargar la \u00faltima versi\u00f3n de la p\u00e1gina de releases . En nuestro caso, la tenemos ya descargada en ~/Desktop/taller-vt/maputnik . Para arrancar la versi\u00f3n local: 1 2 cd ~/Desktop/taller-vt/maputnik live-server --port = 8082 Abrir Maputnik en http://localhost:8082 Comenzar un estilo nuevo En la barra de men\u00fa seleccionamos la opci\u00f3n Open . Del apartado Gallery Styles , seleccionamos Empty Style . Agregar un origen de datos (Source) En la barra de men\u00fa seleccionamos la opci\u00f3n Sources . En la parte inferior del di\u00e1logo est\u00e1 la secci\u00f3n: Add New Source . Como Source ID ponemos naturalearth . Como Source Type seleccionamos Vector (TileJSON URL) . Como TileJSON URL seleccionamos http://localhost:8081/data/natural_earth.json Tambi\u00e9n se podr\u00eda usar como Source Type un Vector (XYZ URL) , en cuyo caso tambi\u00e9n hay que indicar el rango de zooms en que los datos son v\u00e1lidos. Agregar sprite y glyphs En la barra de men\u00fa seleccionamos Style Settings : Name : Nombre del estilo. En nuestro caso pondremos Natural Earth . Sprite URL : Usaremos el sprite de uno de los estilos que tenemos publicados en tileserver http://localhost:8081/styles/osm-bright/sprite Glyphs URL : Accederemos a las tipograf\u00edas publicadas en nuestro Tileserver http://localhost:8081/fonts/{fontstack}/{range}.pbf Simbolizaci\u00f3n b\u00e1sica Presionamos el bot\u00f3n de Add Layer : Fondo A\u00f1adimos una primera capa de fondo: ID : identificador \u00fanico de la capa. Pondremos fondo . Type : tipo de capa. Seleccionar la opci\u00f3n de Background . Seleccionamos el color en Paint properties = Color : \"#F8F4F0\". El fondo del mapa pasa a un gris claro. Oc\u00e9anos A\u00f1adimos ahora los oc\u00e9anos: ID : identificador \u00fanico de la capa. Pondremos oceanos . Type : tipo de capa. Seleccionar la opci\u00f3n de Fill ya que la capa es de tipo pol\u00edgono. Source : identificador del origen de datos. En nuestro caso pondremos naturalearth . Source Layer : identificador de la capa dentro del origen de datos. Pondremos ocean . Aparecer\u00e1n los oc\u00e9anos de color negro. Simbolizamos la capa seleccionando un color RGB en Paint properties = Color : \"#A0C8F0\". En el apartado inferior del panel de propiedades de la capa, vamos viendo la definici\u00f3n tal como se guardar\u00e1 en el fichero json de estilo: 1 2 3 4 5 6 7 8 9 { id : oceanos , type : fill , source : naturalearth , source-layer : ocean , paint : { fill-color : #A0C8F0 } } Maputnik no es m\u00e1s que un asistente gr\u00e1fico para generar el fichero style.json . Resto de capas b\u00e1sicas El resto de capas se puede simbolizar procediendo de la misma manera: id type source-layer color otras propiedades \"paint\" fondo Background -- #F8F4F0 -- oceanos Fill ocean #A0C8F0 -- tierra Fill land #E6C7C7 -- costa Line coastline #4793E8 -- rios Line rivers #4793E8 -- lagos Fill lakes #A0C8F0 Outline color: #4793E8 ferrocarril Line rail #707070 -- carreteras Line roads #BF5757 -- Filtrar los datos a mostrar en una capa Vamos a eliminar las rutas de ferry que se muestran como carreteras. Hay dos maneras de definir un filtro en un estilo MapboxGL: Filters : La forma cl\u00e1sica, que implementa Maputnik: https://www.mapbox.com/mapbox-gl-js/style-spec/#other-filter Decision Expressions : La nueva forma, m\u00e1s potente, pero que Maputnik no implementa: https://www.mapbox.com/mapbox-gl-js/style-spec/#expressions-decision Ahora aprenderemos a crear un Filter con Maputnik, y m\u00e1s adelante aplicaremos Expressions directamente sobre el fichero json de estilo. En Maputnik, seleccionando la capa carreteras , apartado Filter : Presionamos el bot\u00f3n Add filter . La condici\u00f3n ser\u00e1: 1 featurecla == Road Comprobar que desaparecen las l\u00edneas de Ferry en el mapa. Tip Usa el Inspect Mode integrado en Maputnik para explorar los diferentes campos de una capa y sus posibles valores. Ejercicio extra Crea una nueva capa \"ferrys\" y aplica el filtro contrario para mostrar s\u00f3lo las rutas de ferry. Investiga la propiedad Dasharray para darle un aspecto de l\u00ednea discontinua a las rutas. Etiquetar una capa Agregar la capa de ciudades. Presionar el bot\u00f3n de Add Layer y rellenar el formulario con la siguiente informaci\u00f3n: ID : ciudades Type : Symbol , utilizado para mostrar entidades puntuales (iconos y etiquetas) Source : naturalearth Source Layer : cities En el apartado Text layout properties : En la propiedad Field escribir {NAME} (el nombre del campo a mostrar, entre llaves). En la propiedad Font , escribir Comic Sans , tipograf\u00eda que hemos generado y publicado en el apartado anterior (nota: el taller sobre c\u00f3mo hacer mapas bonitos es esta tarde). Utilizar un icono para simbolizar nuestra capa Agregar la capa de aeropuertos. Presionar el bot\u00f3n de Add Layer y rellenar el formulario con la siguiente informaci\u00f3n: ID : aeropuertos Type : Symbol , utilizado para mostrar entidades puntuales (iconos y etiquetas) Source : naturalearth Source Layer : airports En el apartado de Icon layout properties : En la propiedad Image , escribir airport_11 . Este nombre debe coincidir con alguna imagen definida en el sprite. Comprobar que aparecen los aeropuertos en el mapa. Tip Estos son los iconos del sprite del estilo ( osm-bright ) que estamos utilizando: https://github.com/openmaptiles/osm-bright-gl-style/tree/master/icons Exportar el estilo creado Seleccionar la opci\u00f3n Export , y luego el boton de Download para descargar el estilo en nuestro ordenador. Descargamos el archivo, lo renombramos a style.json y lo movemos a la carpeta tileserver/styles/natural-earth/ , donde ya hab\u00edamos copiado los sprites generados en el apartado anterior. 1 cp ~/Downloads/xxxxxx.json ~/Desktop/taller-vt/tileserver/styles/natural-earth/style.json Habr\u00e1 que editar el fichero de configuraci\u00f3n de tileserver tileserver/config.json para a\u00f1adir el estilo: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 styles : { klokantech-basic : { style : klokantech-basic/style.json , tilejson : { bounds : [ 1.898 , 41.246 , 2.312 , 41.533 ] } }, osm-bright : { style : osm-bright/style.json , tilejson : { bounds : [ 1.898 , 41.246 , 2.312 , 41.533 ] } }, natural-earth : { style : natural-earth/style.json } } Reiniciar tileserver y comprobar que ofrece el nuevo estilo de visualizaci\u00f3n. Edici\u00f3n manual del estilo Vamos a dejar Maputnik a un lado y vamos a editar el estilo json a mano. Crear un visor para el nuevo estilo Lo primero ser\u00e1 crear un visor para los datos y estilo de Natural Earth partiendo del visor de Barcelona. Tambi\u00e9n usaremos una copia local del estilo porque ser\u00e1 m\u00e1s f\u00e1cil ir viendo los cambios. Cada vez que guardemos en disco una modificaci\u00f3n del fichero de estilo, podremos recargar directamente la p\u00e1gina en el navegador para reflejar los cambios. Copiar el archivo visor/barcelona.html en visor/naturalearth.html Adem\u00e1s, hacer una copia de tileserver/styles/natural-earth/style.json en visor/natural-earth-style.json . Editaremos visor/naturalearth.html y en la parte de script dejaremos s\u00f3lo este c\u00f3digo: 1 2 3 4 5 6 7 8 9 10 var map = new mapboxgl . Map ({ container : map , style : natural-earth-style.json , center : [ 1.5 , 41 ], zoom : 5 , hash : true }); map . addControl ( new mapboxgl . NavigationControl ()); map . addControl ( new MapboxInspect ()); Abriendo en el navegador http://127.0.0.1:8080/naturalearth.html deber\u00eda verse: Estilo avanzado basado en expresiones El estilo basado en datos permite estilizar los datos en funci\u00f3n del valor de sus propiedades. Por ejemplo, cambiar el radio de un c\u00edrculo o el color de un pol\u00edgono en funci\u00f3n de un valor num\u00e9rico, o usar l\u00f3gica condicional para crear etiquetas multiling\u00fces. Las expresiones de Mapbox GL se pueden usar en cualquier propiedad de tipo layout , paint o filter de una layer . Gracias a las expresiones, una regla de simbolizaci\u00f3n determinada puede calcularse como el resultado de un c\u00e1lculo donde intervienen los valores de una o m\u00e1s propiedades de una feature . Pueden usarse operaciones l\u00f3gicas, matem\u00e1ticas, de generaci\u00f3n de color, interpolaciones, etc. Estilo basado en valores concretos de una propiedad Abrir el fichero natural-earth-style.json y localizar el layer con id carreteras . Vamos a asignar un color distinto en funci\u00f3n del valor de la propiedad type . Para ello usaremos la expresi\u00f3n Match , que asigna a cada valor de entrada un valor de salida distinto (en nuestro caso, un color para cada tipo de carretera): 1 2 3 4 5 6 [ match , propiedad , valorentrada_1 , salida_1 , entrada_2 , salida_2 , ..., salida_por_defecto ] Para obtener el valor de la propiedad de una feature se usa la expresi\u00f3n Get: [\"get\", nombre_propiedad ] . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 { id : carreteras , type : line , source : naturalearth , source-layer : roads , filter : [ all , [ == , featurecla , Road ]], paint : { line-color : [ match , [ get , type ], Major Highway , rgba(20, 52, 232, 1) , Secondary Highway , rgba(206, 32, 79, 1) , Road , rgba(49, 137, 52, 1) , rgba(255, 204, 0, 1) ], line-width : 2 } } Estilo basado en el nivel del zoom Localizar el layer con id ciudades . Vamos a cambiar el tama\u00f1o del texto seg\u00fan el nivel de zoom del mapa, y de la propiedad SCALERANK del dato. Usaremos la expresi\u00f3n Case , que tiene esta forma: 1 2 3 4 5 6 [ case , condicion_1 , salida_1 , condicion_2 , salida_2 , ..., salida_por_defecto ] En nuestro caso la usaremos para decir cosas como: Si \"SCALERANK\" es menor que 2, aplica un tama\u00f1o de letra 20, Si \"SCALERANK\" est\u00e1 entre 3 y 5, aplica un tama\u00f1o de letra 14, En cualquier otro caso, aplica un tama\u00f1o de letra 10 Que quedar\u00eda expresado as\u00ed: 1 2 3 4 5 6 [ case , [ = , [ number ,[ get , SCALERANK ]], 2 ], 20 , [ = , [ number ,[ get , SCALERANK ]], 5 ], 14 , 10 ] El operador \"number\" se usa para convertir el valor SCALERANK a un tipo num\u00e9rico. Y la combinaremos con la expresi\u00f3n Step , que tiene esta forma: 1 2 3 4 5 6 [ step , entrada , salida_inicial , umbral_1 , salida_1 , umbral_2 , salida_2 , ... ] En nuestro caso la podemos usar para decir cosas como: Usa un tama\u00f1o de letra 18 para zooms por debajo de 5. Usa un tama\u00f1o de letra 20 entre el zoom 5 y 8. Usa un tama\u00f1o de letra 24 para zooms mayores que 8. Que quedar\u00eda: 1 2 3 4 5 [ step , [ zoom ], 18 , 5 , 20 , 8 , 24 ] Obviamente podemos combinar ambas expresiones, de forma que la salida para cada nivel de zoom no sea un tama\u00f1o de letra concreto, sino que dependa de \"SCALERANK\". Y nos queda el siguiente monstruo para el Layer: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 { id : ciudades , type : symbol , source : naturalearth , source-layer : cities , layout : { text-field : {NAME} , text-anchor : bottom , text-offset : [ 0 , -1 ], text-size : [ step , [ zoom ], [ case , [ , [ number , [ get , SCALERANK ]], 3 ], 18 , 0 ], 5 , [ case , [ = , [ number ,[ get , SCALERANK ]], 2 ], 20 , [ = , [ number ,[ get , SCALERANK ]], 5 ], 14 , 10 ], 8 , [ case , [ = , [ number ,[ get , SCALERANK ]], 2 ], 24 , [ = , [ number ,[ get , SCALERANK ]], 5 ], 18 , 14 ] ] }, paint : { text-halo-color : rgba(253, 253, 253, 1) , text-color : rgba(16, 16, 16, 1) , text-halo-width : 1.5 } } Como se puede observar, las expresiones son tan potentes como dif\u00edciles de escribir bien a la primera. Estilo basado en una propiedad Vamos a crear un nuevo layer llamado ciudades-circle , y la vamos a definir a continuaci\u00f3n de ciudades y justo antes de aeropuertos . Dibujaremos un c\u00edrculo cuyo tama\u00f1o ser\u00e1 inversamente proporcional a la propiedad SCALERANK . Adem\u00e1s, las capitales estatales se simbolizar\u00e1n como un c\u00edrculo blanco con un borde grueso, y el resto de ciudades con un c\u00edrculo gris con borde m\u00e1s fino. Usaremos la misma expresi\u00f3n Match que hemos visto anteriormente, aplicada a un color y a un grueso de l\u00ednea. Adem\u00e1s, aplicaremos una expresi\u00f3n matem\u00e1tica [\"-\"] , que resta dos valores, de manera que el tama\u00f1o del c\u00edrculo ser\u00e1 10 - SCALERANK : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 { id : ciudades-circle , type : circle , source : naturalearth , source-layer : cities , paint : { circle-color : [ match , [ get , ADM0CAP ], 0 , #888 , #FFF ], circle-stroke-width : [ match , [ get , ADM0CAP ], 0 , 1 , 2 ], circle-radius : [ - , 10 , [ get , SCALERANK ]] } } Uso de fuentes de datos externas Por \u00faltimo, vamos a a\u00f1adir un fondo raster al mapa, procedente de otro tileserver. A\u00f1adiremos un nuevo source de tipo raster , a continuaci\u00f3n del source naturalearth : 1 2 3 4 5 6 7 8 9 10 11 12 sources : { naturalearth : { type : vector , url : http://localhost:8081/data/natural_earth.json }, relief : { type : raster , tiles : [ http://naturalearthtiles.lukasmartinelli.ch/tiles/natural_earth_2_shaded_relief.raster/{z}/{x}/{y}.png ], tileSize : 256 , maxzoom : 6 } } Borraremos el layer llamado tierra . A\u00f1adiremos un nuevo layer justo despu\u00e9s del fondo que se llamar\u00e1 terreno : 1 2 3 4 5 { id : terreno , type : raster , source : relief } El resultado final de aplicar todos estos estilos tendr\u00e1 este aspecto: Ejercicio extra: uso de una fuente con iconos para simbolizar un punto Si se ha hecho el ejercicio extra del apartado anterior, en el que cre\u00e1bamos una fuente a partir de una colecci\u00f3n de iconos, ahora veremos c\u00f3mo utilizarla en el Layer de aeropuertos: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 { id : aeropuertos , type : symbol , source : naturalearth , source-layer : airports , layout : { icon-image : , text-font : [ Geostart Regular ], text-size : 25 , text-field : , }, paint : { text-color : #fabada , text-halo-color : #888 , text-halo-width : 2 } } En las l\u00edneas destacadas se observa c\u00f3mo no se usa una icon-image , sino una etiqueta de texto ( text-font , text-size y text-field ). En text-field se indica una coma \",\" , que corresponde al icono que queremos mostrar. Al tratarse de una fuente, podemos indicar el tama\u00f1o que queramos sin miedo a obtener una imagen pixelada, y aplicar otras propiedades como escoger color, halo, etc. Como resultado del estilo indicado se simbolizar\u00edan los aeropuertos as\u00ed:","title":"6. C\u00f3mo simbolizarlas"},{"location":"6_estilos/#como-simbolizar-teselas-vectoriales","text":"","title":"C\u00f3mo simbolizar teselas vectoriales"},{"location":"6_estilos/#maputnik","text":"Es un editor visual gratuito y abierto para estilos Mapbox GL dirigidos tanto a desarrolladores como a dise\u00f1adores de mapas. Se puede utilizar en l\u00ednea en Maputnik editor o se puede hacer una instalaci\u00f3n local.","title":"Maputnik"},{"location":"6_estilos/#instalacion","text":"Se puede descargar la \u00faltima versi\u00f3n de la p\u00e1gina de releases . En nuestro caso, la tenemos ya descargada en ~/Desktop/taller-vt/maputnik . Para arrancar la versi\u00f3n local: 1 2 cd ~/Desktop/taller-vt/maputnik live-server --port = 8082 Abrir Maputnik en http://localhost:8082","title":"Instalaci\u00f3n"},{"location":"6_estilos/#comenzar-un-estilo-nuevo","text":"En la barra de men\u00fa seleccionamos la opci\u00f3n Open . Del apartado Gallery Styles , seleccionamos Empty Style .","title":"Comenzar un estilo nuevo"},{"location":"6_estilos/#agregar-un-origen-de-datos-source","text":"En la barra de men\u00fa seleccionamos la opci\u00f3n Sources . En la parte inferior del di\u00e1logo est\u00e1 la secci\u00f3n: Add New Source . Como Source ID ponemos naturalearth . Como Source Type seleccionamos Vector (TileJSON URL) . Como TileJSON URL seleccionamos http://localhost:8081/data/natural_earth.json Tambi\u00e9n se podr\u00eda usar como Source Type un Vector (XYZ URL) , en cuyo caso tambi\u00e9n hay que indicar el rango de zooms en que los datos son v\u00e1lidos.","title":"Agregar un origen de datos (Source)"},{"location":"6_estilos/#agregar-sprite-y-glyphs","text":"En la barra de men\u00fa seleccionamos Style Settings : Name : Nombre del estilo. En nuestro caso pondremos Natural Earth . Sprite URL : Usaremos el sprite de uno de los estilos que tenemos publicados en tileserver http://localhost:8081/styles/osm-bright/sprite Glyphs URL : Accederemos a las tipograf\u00edas publicadas en nuestro Tileserver http://localhost:8081/fonts/{fontstack}/{range}.pbf","title":"Agregar sprite y glyphs"},{"location":"6_estilos/#simbolizacion-basica","text":"Presionamos el bot\u00f3n de Add Layer :","title":"Simbolizaci\u00f3n b\u00e1sica"},{"location":"6_estilos/#fondo","text":"A\u00f1adimos una primera capa de fondo: ID : identificador \u00fanico de la capa. Pondremos fondo . Type : tipo de capa. Seleccionar la opci\u00f3n de Background . Seleccionamos el color en Paint properties = Color : \"#F8F4F0\". El fondo del mapa pasa a un gris claro.","title":"Fondo"},{"location":"6_estilos/#oceanos","text":"A\u00f1adimos ahora los oc\u00e9anos: ID : identificador \u00fanico de la capa. Pondremos oceanos . Type : tipo de capa. Seleccionar la opci\u00f3n de Fill ya que la capa es de tipo pol\u00edgono. Source : identificador del origen de datos. En nuestro caso pondremos naturalearth . Source Layer : identificador de la capa dentro del origen de datos. Pondremos ocean . Aparecer\u00e1n los oc\u00e9anos de color negro. Simbolizamos la capa seleccionando un color RGB en Paint properties = Color : \"#A0C8F0\". En el apartado inferior del panel de propiedades de la capa, vamos viendo la definici\u00f3n tal como se guardar\u00e1 en el fichero json de estilo: 1 2 3 4 5 6 7 8 9 { id : oceanos , type : fill , source : naturalearth , source-layer : ocean , paint : { fill-color : #A0C8F0 } } Maputnik no es m\u00e1s que un asistente gr\u00e1fico para generar el fichero style.json .","title":"Oc\u00e9anos"},{"location":"6_estilos/#resto-de-capas-basicas","text":"El resto de capas se puede simbolizar procediendo de la misma manera: id type source-layer color otras propiedades \"paint\" fondo Background -- #F8F4F0 -- oceanos Fill ocean #A0C8F0 -- tierra Fill land #E6C7C7 -- costa Line coastline #4793E8 -- rios Line rivers #4793E8 -- lagos Fill lakes #A0C8F0 Outline color: #4793E8 ferrocarril Line rail #707070 -- carreteras Line roads #BF5757 --","title":"Resto de capas b\u00e1sicas"},{"location":"6_estilos/#filtrar-los-datos-a-mostrar-en-una-capa","text":"Vamos a eliminar las rutas de ferry que se muestran como carreteras. Hay dos maneras de definir un filtro en un estilo MapboxGL: Filters : La forma cl\u00e1sica, que implementa Maputnik: https://www.mapbox.com/mapbox-gl-js/style-spec/#other-filter Decision Expressions : La nueva forma, m\u00e1s potente, pero que Maputnik no implementa: https://www.mapbox.com/mapbox-gl-js/style-spec/#expressions-decision Ahora aprenderemos a crear un Filter con Maputnik, y m\u00e1s adelante aplicaremos Expressions directamente sobre el fichero json de estilo. En Maputnik, seleccionando la capa carreteras , apartado Filter : Presionamos el bot\u00f3n Add filter . La condici\u00f3n ser\u00e1: 1 featurecla == Road Comprobar que desaparecen las l\u00edneas de Ferry en el mapa. Tip Usa el Inspect Mode integrado en Maputnik para explorar los diferentes campos de una capa y sus posibles valores.","title":"Filtrar los datos a mostrar en una capa"},{"location":"6_estilos/#ejercicio-extra","text":"Crea una nueva capa \"ferrys\" y aplica el filtro contrario para mostrar s\u00f3lo las rutas de ferry. Investiga la propiedad Dasharray para darle un aspecto de l\u00ednea discontinua a las rutas.","title":"Ejercicio extra"},{"location":"6_estilos/#etiquetar-una-capa","text":"Agregar la capa de ciudades. Presionar el bot\u00f3n de Add Layer y rellenar el formulario con la siguiente informaci\u00f3n: ID : ciudades Type : Symbol , utilizado para mostrar entidades puntuales (iconos y etiquetas) Source : naturalearth Source Layer : cities En el apartado Text layout properties : En la propiedad Field escribir {NAME} (el nombre del campo a mostrar, entre llaves). En la propiedad Font , escribir Comic Sans , tipograf\u00eda que hemos generado y publicado en el apartado anterior (nota: el taller sobre c\u00f3mo hacer mapas bonitos es esta tarde).","title":"Etiquetar una capa"},{"location":"6_estilos/#utilizar-un-icono-para-simbolizar-nuestra-capa","text":"Agregar la capa de aeropuertos. Presionar el bot\u00f3n de Add Layer y rellenar el formulario con la siguiente informaci\u00f3n: ID : aeropuertos Type : Symbol , utilizado para mostrar entidades puntuales (iconos y etiquetas) Source : naturalearth Source Layer : airports En el apartado de Icon layout properties : En la propiedad Image , escribir airport_11 . Este nombre debe coincidir con alguna imagen definida en el sprite. Comprobar que aparecen los aeropuertos en el mapa. Tip Estos son los iconos del sprite del estilo ( osm-bright ) que estamos utilizando: https://github.com/openmaptiles/osm-bright-gl-style/tree/master/icons","title":"Utilizar un icono para simbolizar nuestra capa"},{"location":"6_estilos/#exportar-el-estilo-creado","text":"Seleccionar la opci\u00f3n Export , y luego el boton de Download para descargar el estilo en nuestro ordenador. Descargamos el archivo, lo renombramos a style.json y lo movemos a la carpeta tileserver/styles/natural-earth/ , donde ya hab\u00edamos copiado los sprites generados en el apartado anterior. 1 cp ~/Downloads/xxxxxx.json ~/Desktop/taller-vt/tileserver/styles/natural-earth/style.json Habr\u00e1 que editar el fichero de configuraci\u00f3n de tileserver tileserver/config.json para a\u00f1adir el estilo: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 styles : { klokantech-basic : { style : klokantech-basic/style.json , tilejson : { bounds : [ 1.898 , 41.246 , 2.312 , 41.533 ] } }, osm-bright : { style : osm-bright/style.json , tilejson : { bounds : [ 1.898 , 41.246 , 2.312 , 41.533 ] } }, natural-earth : { style : natural-earth/style.json } } Reiniciar tileserver y comprobar que ofrece el nuevo estilo de visualizaci\u00f3n.","title":"Exportar el estilo creado"},{"location":"6_estilos/#edicion-manual-del-estilo","text":"Vamos a dejar Maputnik a un lado y vamos a editar el estilo json a mano.","title":"Edici\u00f3n manual del estilo"},{"location":"6_estilos/#crear-un-visor-para-el-nuevo-estilo","text":"Lo primero ser\u00e1 crear un visor para los datos y estilo de Natural Earth partiendo del visor de Barcelona. Tambi\u00e9n usaremos una copia local del estilo porque ser\u00e1 m\u00e1s f\u00e1cil ir viendo los cambios. Cada vez que guardemos en disco una modificaci\u00f3n del fichero de estilo, podremos recargar directamente la p\u00e1gina en el navegador para reflejar los cambios. Copiar el archivo visor/barcelona.html en visor/naturalearth.html Adem\u00e1s, hacer una copia de tileserver/styles/natural-earth/style.json en visor/natural-earth-style.json . Editaremos visor/naturalearth.html y en la parte de script dejaremos s\u00f3lo este c\u00f3digo: 1 2 3 4 5 6 7 8 9 10 var map = new mapboxgl . Map ({ container : map , style : natural-earth-style.json , center : [ 1.5 , 41 ], zoom : 5 , hash : true }); map . addControl ( new mapboxgl . NavigationControl ()); map . addControl ( new MapboxInspect ()); Abriendo en el navegador http://127.0.0.1:8080/naturalearth.html deber\u00eda verse:","title":"Crear un visor para el nuevo estilo"},{"location":"6_estilos/#estilo-avanzado-basado-en-expresiones","text":"El estilo basado en datos permite estilizar los datos en funci\u00f3n del valor de sus propiedades. Por ejemplo, cambiar el radio de un c\u00edrculo o el color de un pol\u00edgono en funci\u00f3n de un valor num\u00e9rico, o usar l\u00f3gica condicional para crear etiquetas multiling\u00fces. Las expresiones de Mapbox GL se pueden usar en cualquier propiedad de tipo layout , paint o filter de una layer . Gracias a las expresiones, una regla de simbolizaci\u00f3n determinada puede calcularse como el resultado de un c\u00e1lculo donde intervienen los valores de una o m\u00e1s propiedades de una feature . Pueden usarse operaciones l\u00f3gicas, matem\u00e1ticas, de generaci\u00f3n de color, interpolaciones, etc.","title":"Estilo avanzado basado en expresiones"},{"location":"6_estilos/#estilo-basado-en-valores-concretos-de-una-propiedad","text":"Abrir el fichero natural-earth-style.json y localizar el layer con id carreteras . Vamos a asignar un color distinto en funci\u00f3n del valor de la propiedad type . Para ello usaremos la expresi\u00f3n Match , que asigna a cada valor de entrada un valor de salida distinto (en nuestro caso, un color para cada tipo de carretera): 1 2 3 4 5 6 [ match , propiedad , valorentrada_1 , salida_1 , entrada_2 , salida_2 , ..., salida_por_defecto ] Para obtener el valor de la propiedad de una feature se usa la expresi\u00f3n Get: [\"get\", nombre_propiedad ] . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 { id : carreteras , type : line , source : naturalearth , source-layer : roads , filter : [ all , [ == , featurecla , Road ]], paint : { line-color : [ match , [ get , type ], Major Highway , rgba(20, 52, 232, 1) , Secondary Highway , rgba(206, 32, 79, 1) , Road , rgba(49, 137, 52, 1) , rgba(255, 204, 0, 1) ], line-width : 2 } }","title":"Estilo basado en valores concretos de una propiedad"},{"location":"6_estilos/#estilo-basado-en-el-nivel-del-zoom","text":"Localizar el layer con id ciudades . Vamos a cambiar el tama\u00f1o del texto seg\u00fan el nivel de zoom del mapa, y de la propiedad SCALERANK del dato. Usaremos la expresi\u00f3n Case , que tiene esta forma: 1 2 3 4 5 6 [ case , condicion_1 , salida_1 , condicion_2 , salida_2 , ..., salida_por_defecto ] En nuestro caso la usaremos para decir cosas como: Si \"SCALERANK\" es menor que 2, aplica un tama\u00f1o de letra 20, Si \"SCALERANK\" est\u00e1 entre 3 y 5, aplica un tama\u00f1o de letra 14, En cualquier otro caso, aplica un tama\u00f1o de letra 10 Que quedar\u00eda expresado as\u00ed: 1 2 3 4 5 6 [ case , [ = , [ number ,[ get , SCALERANK ]], 2 ], 20 , [ = , [ number ,[ get , SCALERANK ]], 5 ], 14 , 10 ] El operador \"number\" se usa para convertir el valor SCALERANK a un tipo num\u00e9rico. Y la combinaremos con la expresi\u00f3n Step , que tiene esta forma: 1 2 3 4 5 6 [ step , entrada , salida_inicial , umbral_1 , salida_1 , umbral_2 , salida_2 , ... ] En nuestro caso la podemos usar para decir cosas como: Usa un tama\u00f1o de letra 18 para zooms por debajo de 5. Usa un tama\u00f1o de letra 20 entre el zoom 5 y 8. Usa un tama\u00f1o de letra 24 para zooms mayores que 8. Que quedar\u00eda: 1 2 3 4 5 [ step , [ zoom ], 18 , 5 , 20 , 8 , 24 ] Obviamente podemos combinar ambas expresiones, de forma que la salida para cada nivel de zoom no sea un tama\u00f1o de letra concreto, sino que dependa de \"SCALERANK\". Y nos queda el siguiente monstruo para el Layer: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 { id : ciudades , type : symbol , source : naturalearth , source-layer : cities , layout : { text-field : {NAME} , text-anchor : bottom , text-offset : [ 0 , -1 ], text-size : [ step , [ zoom ], [ case , [ , [ number , [ get , SCALERANK ]], 3 ], 18 , 0 ], 5 , [ case , [ = , [ number ,[ get , SCALERANK ]], 2 ], 20 , [ = , [ number ,[ get , SCALERANK ]], 5 ], 14 , 10 ], 8 , [ case , [ = , [ number ,[ get , SCALERANK ]], 2 ], 24 , [ = , [ number ,[ get , SCALERANK ]], 5 ], 18 , 14 ] ] }, paint : { text-halo-color : rgba(253, 253, 253, 1) , text-color : rgba(16, 16, 16, 1) , text-halo-width : 1.5 } } Como se puede observar, las expresiones son tan potentes como dif\u00edciles de escribir bien a la primera.","title":"Estilo basado en el nivel del zoom"},{"location":"6_estilos/#estilo-basado-en-una-propiedad","text":"Vamos a crear un nuevo layer llamado ciudades-circle , y la vamos a definir a continuaci\u00f3n de ciudades y justo antes de aeropuertos . Dibujaremos un c\u00edrculo cuyo tama\u00f1o ser\u00e1 inversamente proporcional a la propiedad SCALERANK . Adem\u00e1s, las capitales estatales se simbolizar\u00e1n como un c\u00edrculo blanco con un borde grueso, y el resto de ciudades con un c\u00edrculo gris con borde m\u00e1s fino. Usaremos la misma expresi\u00f3n Match que hemos visto anteriormente, aplicada a un color y a un grueso de l\u00ednea. Adem\u00e1s, aplicaremos una expresi\u00f3n matem\u00e1tica [\"-\"] , que resta dos valores, de manera que el tama\u00f1o del c\u00edrculo ser\u00e1 10 - SCALERANK : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 { id : ciudades-circle , type : circle , source : naturalearth , source-layer : cities , paint : { circle-color : [ match , [ get , ADM0CAP ], 0 , #888 , #FFF ], circle-stroke-width : [ match , [ get , ADM0CAP ], 0 , 1 , 2 ], circle-radius : [ - , 10 , [ get , SCALERANK ]] } }","title":"Estilo basado en una propiedad"},{"location":"6_estilos/#uso-de-fuentes-de-datos-externas","text":"Por \u00faltimo, vamos a a\u00f1adir un fondo raster al mapa, procedente de otro tileserver. A\u00f1adiremos un nuevo source de tipo raster , a continuaci\u00f3n del source naturalearth : 1 2 3 4 5 6 7 8 9 10 11 12 sources : { naturalearth : { type : vector , url : http://localhost:8081/data/natural_earth.json }, relief : { type : raster , tiles : [ http://naturalearthtiles.lukasmartinelli.ch/tiles/natural_earth_2_shaded_relief.raster/{z}/{x}/{y}.png ], tileSize : 256 , maxzoom : 6 } } Borraremos el layer llamado tierra . A\u00f1adiremos un nuevo layer justo despu\u00e9s del fondo que se llamar\u00e1 terreno : 1 2 3 4 5 { id : terreno , type : raster , source : relief } El resultado final de aplicar todos estos estilos tendr\u00e1 este aspecto:","title":"Uso de fuentes de datos externas"},{"location":"6_estilos/#ejercicio-extra-uso-de-una-fuente-con-iconos-para-simbolizar-un-punto","text":"Si se ha hecho el ejercicio extra del apartado anterior, en el que cre\u00e1bamos una fuente a partir de una colecci\u00f3n de iconos, ahora veremos c\u00f3mo utilizarla en el Layer de aeropuertos: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 { id : aeropuertos , type : symbol , source : naturalearth , source-layer : airports , layout : { icon-image : , text-font : [ Geostart Regular ], text-size : 25 , text-field : , }, paint : { text-color : #fabada , text-halo-color : #888 , text-halo-width : 2 } } En las l\u00edneas destacadas se observa c\u00f3mo no se usa una icon-image , sino una etiqueta de texto ( text-font , text-size y text-field ). En text-field se indica una coma \",\" , que corresponde al icono que queremos mostrar. Al tratarse de una fuente, podemos indicar el tama\u00f1o que queramos sin miedo a obtener una imagen pixelada, y aplicar otras propiedades como escoger color, halo, etc. Como resultado del estilo indicado se simbolizar\u00edan los aeropuertos as\u00ed:","title":"Ejercicio extra: uso de una fuente con iconos para simbolizar un punto"},{"location":"7_servidor_dinamico/","text":"C\u00f3mo servir datos din\u00e1micos Partiremos de unos datos con los distritos, barrios y secciones censales de Barcelona. Los datos est\u00e1n en datos/bcn_geodata.sql . Note El origen de los datos es Ajuntament de Barcelona CC-by ( http://w20.bcn.cat/cartobcn/ ). Mart\u00edn Gonz\u00e1lez los convirti\u00f3 a GeoJSON ( https://github.com/martgnz/bcn-geodata ). Para el taller los hemos convertido de GeoJSON a PostGIS. Cargarlos en PostGIS: 1 2 cd ~/Desktop/taller-vt psql -U user datos/bcn_geodata.sql Se crear\u00e1 una BDD bcn_geodata con las tablas barrios , distritos y seccion_censal . Se puede acceder a esta BDD con el usuario user , password user . Una vez con los datos cargados en PostGIS, usaremos tegola para levantar un servidor de teselas vectoriales partir de una BDD PostGIS. Instalando Tegola Tegola consiste en un solo fichero ejecutable. La instalaci\u00f3n consiste en descargarse un zip, descomprimirlo, y copiar el fichero ejecutable resultante en una ruta localizable: 1 2 3 wget https://github.com/go-spatial/tegola/releases/download/v0.6.3/tegola_linux_amd64.zip unzip tegola_linux_amd64.zip sudo mv tegola_linux_amd64 /usr/local/bin/tegola Comprobar que puede ejecutarse tegola correctamente, y borrar el zip: 1 2 tegola -h # comprobar instalacion rm tegola_linux_amd64.zip Configurando Tegola Tegola necesita de un fichero de configuraci\u00f3n en formato toml para funcionar. En \u00e9l estableceremos los par\u00e1metros de conexi\u00f3n con la BDD y las caracter\u00edsticas de las capas que queremos servir. Creemos pues un directorio llamado tegola , y en \u00e9l, un fichero llamado config.toml . 1 2 3 mkdir tegola cd tegola touch config.toml Lo primero es definir una secci\u00f3n con el puerto que usaremos para levantar el servicio: 1 2 [webserver] port = :8083 A continuaci\u00f3n definimos la conexi\u00f3n con la BDD en una secci\u00f3n providers . Dentro del provider, definimos las capas de datos que queremos obtener de la BDD. En nuestro caso son muy sencillas: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 [[providers]] name = postgis type = postgis host = localhost port = 5432 database = bcn_geodata user = user password = user [[providers.layers]] name = distritos tablename = distritos [[providers.layers]] name = barrios tablename = barrios [[providers.layers]] name = seccion_censal tablename = seccion_censal En estas providers.layers tambi\u00e9n se podr\u00edan seleccionar qu\u00e9 columnas queremos obtener, o incluso indicar una consulta SQL para generar la capa, haciendo JOIN de varias tablas, aplicando operaciones espaciales, etc. En nuestro caso, servimos las tablas tal cual. Finalmente, creamos una secci\u00f3n maps , que consiste en un nombre, y una serie de capas de informaci\u00f3n: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 [[maps]] name = bcn_geodata attribution = CC-by Ajuntament de Barcelona center = [2.175, 41.39, 13.0] bounds = [1.898, 41.246, 2.312, 41.533] [[maps.layers]] provider_layer = postgis.seccion_censal dont_simplify = true min_zoom = 11 max_zoom = 16 [[maps.layers]] provider_layer = postgis.barrios dont_simplify = true min_zoom = 10 max_zoom = 16 [[maps.layers]] provider_layer = postgis.distritos dont_simplify = true min_zoom = 0 max_zoom = 16 En estas maps.layers se indican par\u00e1metros para la generaci\u00f3n de las VT, como el rango de niveles de zoom en las que ser\u00e1n visibles, si se simplificar\u00e1 o no la geometr\u00eda. En la configuraci\u00f3n tambi\u00e9n existe la posibilidad de activar una cach\u00e9 en disco, en s3 o en redis, as\u00ed como comandos para invalidar partes de la cach\u00e9. En nuestro caso, no hemos usado cach\u00e9. Arrancando tegola Arrancamos el servicio desde el directorio donde hayamos guardato config.toml : 1 2 ~/Desktop/taller-vt/tegola tegola serve Y abrimos http://localhost:8083 : Activando \"Inspect Features\" podremos ver los atributos de cada elemento. Las teselas est\u00e1n disponibles en: http://localhost:8083/maps/bcn_geodata/{z}/{x}/{y}.pbf Incorporando los datos en el visor de Barcelona Sustituiremos el contenido de map.on('load', ...) , y donde antes agreg\u00e1bamos los edificios de catastro en 3D, ahora agregaremos las secciones censales. El c\u00f3digo es: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 map . on ( load , function () { map . addSource ( bcn_geodata , { type : vector , tiles : [ http://localhost:8083/maps/bcn_geodata/{z}/{x}/{y}.pbf ] }); map . addLayer ({ id : seccion_censal , source : bcn_geodata , source-layer : seccion_censal , type : fill , paint : { fill-opacity : 0.6 , fill-color : #fcc , fill-outline-color : #000 } }); }); Tem\u00e1tico avanzado Expresiones matem\u00e1ticas En las tablas tenemos los campos de poblaci\u00f3n divididos en hombres ( homes ) y mujeres ( dones ), as\u00ed como el \u00e1rea en m\u00b2 de cada secci\u00f3n. Con estos datos, podemos calcular la densidad de poblaci\u00f3n en habitantes/km\u00b2 seg\u00fan la f\u00f3rmula: 1 densidad = (homes+dones)/(area/1000000) El estilo de mapbox-gl permite expresar operaciones matem\u00e1ticas usando expresiones , de la forma: [\"+\", [\"get\", \"homes\"], [\"get\", \"dones\"]] para sumar la poblaci\u00f3n de hombres y de mujeres [\"/\", [\"get\", \"area\"], 1000000] para pasar el \u00e1rea de m\u00b2 a km\u00b2 Y, combinando ambas, obtenemos la densidad de poblaci\u00f3n en habitantes/km\u00b2: 1 2 3 4 [ / , [ + , [ get , homes ], [ get , dones ]], [ / , [ get , area ], 1000000 ] ] Rampas de color As\u00ed mismo, las expresiones de los estilos de mapbox-gl nos permiten aplicar un n\u00famero discreto de valores de salida a rangos de entrada . Las definiciones del manual sin un ejemplo concreto son algo dif\u00edciles de leer: 1 2 3 4 5 6 [ step , input: number , stop_output_ 0 : OutputType , stop_input_ 1 : number , stop_output_ 1 : OutputType , stop_input_n: number , stop_output_n: OutputType , ... ] : OutputType Pero supongamos que queremos aplicar esta expresi\u00f3n para asignar tres colores en funci\u00f3n de rangos de densidad ( 10.000 hab/km\u00b2 , de 10.000 a 25.000 hab/km\u00b2 , y 25.000 hab/km\u00b2 ), la expresi\u00f3n ser\u00eda: 1 2 3 4 5 6 [ step , [ get , densidad ], Color_1 , 10000 , Color_2 , 25000 , Color_3 ] M\u00e1s sencillo de lo que parec\u00eda. Combinando ambas expresiones Podemos combinar ambas expresiones: \"calcula la densidad y luego asigna un color en funci\u00f3n de su valor\" 1 2 3 4 5 6 7 8 9 10 11 12 13 [ step , [ / , [ + , [ get , homes ], [ get , dones ]], [ / , [ get , area ], 1000000 ] ], #3d5941 , 17703 , #778868 , 29678 , #b5b991 , 37617 , #f6edbd , 46016 , #edbb8a , 54401 , #de8a5a , 66570 , #ca562c ] Tip Los valores de corte para los diferentes colore se han obtenido calculando los cuantiles con PostgreSQL: 1 2 3 4 5 6 7 SELECT ntile , CAST ( min ( densitat ) AS INTEGER ) AS minAmount , CAST ( max ( densitat ) AS INTEGER ) AS maxAmount FROM ( SELECT ( homes + dones ) / ( area / 1000000 ) as densitat , ntile ( 7 ) OVER ( ORDER BY ( homes + dones ) / ( area / 1000000 )) AS ntile FROM seccion_censal ) x GROUP BY ntile ORDER BY ntile ; Y la rampa de color y sus valores RGB de cada color se han obtenido de carto-colors , que a su vez est\u00e1n inspirados en ColorBrewer. Aplicada a la propiedad fill-color del estilo: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 map . addLayer ({ id : seccion_censal , source : bcn_geodata , source-layer : seccion_censal , type : fill , paint : { fill-opacity : 0.75 , fill-color : [ step , [ / , [ + , [ get , homes ], [ get , dones ]], [ / , [ get , area ], 1000000 ] ], #3d5941 , 17703 , #778868 , 29678 , #b5b991 , 37617 , #f6edbd , 46016 , #edbb8a , 54401 , #de8a5a , 66570 , #ca562c ], fill-outline-color : #000 } }); Obtendremos: Ejercicio extra: A\u00f1adir extrusi\u00f3n 3D Aplicar una extrusi\u00f3n a cada secci\u00f3n censal de altura proporcional a su densidad de poblaci\u00f3n:","title":"7. C\u00f3mo servir datos din\u00e1micos"},{"location":"7_servidor_dinamico/#como-servir-datos-dinamicos","text":"Partiremos de unos datos con los distritos, barrios y secciones censales de Barcelona. Los datos est\u00e1n en datos/bcn_geodata.sql . Note El origen de los datos es Ajuntament de Barcelona CC-by ( http://w20.bcn.cat/cartobcn/ ). Mart\u00edn Gonz\u00e1lez los convirti\u00f3 a GeoJSON ( https://github.com/martgnz/bcn-geodata ). Para el taller los hemos convertido de GeoJSON a PostGIS. Cargarlos en PostGIS: 1 2 cd ~/Desktop/taller-vt psql -U user datos/bcn_geodata.sql Se crear\u00e1 una BDD bcn_geodata con las tablas barrios , distritos y seccion_censal . Se puede acceder a esta BDD con el usuario user , password user . Una vez con los datos cargados en PostGIS, usaremos tegola para levantar un servidor de teselas vectoriales partir de una BDD PostGIS.","title":"C\u00f3mo servir datos din\u00e1micos"},{"location":"7_servidor_dinamico/#instalando-tegola","text":"Tegola consiste en un solo fichero ejecutable. La instalaci\u00f3n consiste en descargarse un zip, descomprimirlo, y copiar el fichero ejecutable resultante en una ruta localizable: 1 2 3 wget https://github.com/go-spatial/tegola/releases/download/v0.6.3/tegola_linux_amd64.zip unzip tegola_linux_amd64.zip sudo mv tegola_linux_amd64 /usr/local/bin/tegola Comprobar que puede ejecutarse tegola correctamente, y borrar el zip: 1 2 tegola -h # comprobar instalacion rm tegola_linux_amd64.zip","title":"Instalando Tegola"},{"location":"7_servidor_dinamico/#configurando-tegola","text":"Tegola necesita de un fichero de configuraci\u00f3n en formato toml para funcionar. En \u00e9l estableceremos los par\u00e1metros de conexi\u00f3n con la BDD y las caracter\u00edsticas de las capas que queremos servir. Creemos pues un directorio llamado tegola , y en \u00e9l, un fichero llamado config.toml . 1 2 3 mkdir tegola cd tegola touch config.toml Lo primero es definir una secci\u00f3n con el puerto que usaremos para levantar el servicio: 1 2 [webserver] port = :8083 A continuaci\u00f3n definimos la conexi\u00f3n con la BDD en una secci\u00f3n providers . Dentro del provider, definimos las capas de datos que queremos obtener de la BDD. En nuestro caso son muy sencillas: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 [[providers]] name = postgis type = postgis host = localhost port = 5432 database = bcn_geodata user = user password = user [[providers.layers]] name = distritos tablename = distritos [[providers.layers]] name = barrios tablename = barrios [[providers.layers]] name = seccion_censal tablename = seccion_censal En estas providers.layers tambi\u00e9n se podr\u00edan seleccionar qu\u00e9 columnas queremos obtener, o incluso indicar una consulta SQL para generar la capa, haciendo JOIN de varias tablas, aplicando operaciones espaciales, etc. En nuestro caso, servimos las tablas tal cual. Finalmente, creamos una secci\u00f3n maps , que consiste en un nombre, y una serie de capas de informaci\u00f3n: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 [[maps]] name = bcn_geodata attribution = CC-by Ajuntament de Barcelona center = [2.175, 41.39, 13.0] bounds = [1.898, 41.246, 2.312, 41.533] [[maps.layers]] provider_layer = postgis.seccion_censal dont_simplify = true min_zoom = 11 max_zoom = 16 [[maps.layers]] provider_layer = postgis.barrios dont_simplify = true min_zoom = 10 max_zoom = 16 [[maps.layers]] provider_layer = postgis.distritos dont_simplify = true min_zoom = 0 max_zoom = 16 En estas maps.layers se indican par\u00e1metros para la generaci\u00f3n de las VT, como el rango de niveles de zoom en las que ser\u00e1n visibles, si se simplificar\u00e1 o no la geometr\u00eda. En la configuraci\u00f3n tambi\u00e9n existe la posibilidad de activar una cach\u00e9 en disco, en s3 o en redis, as\u00ed como comandos para invalidar partes de la cach\u00e9. En nuestro caso, no hemos usado cach\u00e9.","title":"Configurando Tegola"},{"location":"7_servidor_dinamico/#arrancando-tegola","text":"Arrancamos el servicio desde el directorio donde hayamos guardato config.toml : 1 2 ~/Desktop/taller-vt/tegola tegola serve Y abrimos http://localhost:8083 : Activando \"Inspect Features\" podremos ver los atributos de cada elemento. Las teselas est\u00e1n disponibles en: http://localhost:8083/maps/bcn_geodata/{z}/{x}/{y}.pbf","title":"Arrancando tegola"},{"location":"7_servidor_dinamico/#incorporando-los-datos-en-el-visor-de-barcelona","text":"Sustituiremos el contenido de map.on('load', ...) , y donde antes agreg\u00e1bamos los edificios de catastro en 3D, ahora agregaremos las secciones censales. El c\u00f3digo es: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 map . on ( load , function () { map . addSource ( bcn_geodata , { type : vector , tiles : [ http://localhost:8083/maps/bcn_geodata/{z}/{x}/{y}.pbf ] }); map . addLayer ({ id : seccion_censal , source : bcn_geodata , source-layer : seccion_censal , type : fill , paint : { fill-opacity : 0.6 , fill-color : #fcc , fill-outline-color : #000 } }); });","title":"Incorporando los datos en el visor de Barcelona"},{"location":"7_servidor_dinamico/#tematico-avanzado","text":"","title":"Tem\u00e1tico avanzado"},{"location":"7_servidor_dinamico/#expresiones-matematicas","text":"En las tablas tenemos los campos de poblaci\u00f3n divididos en hombres ( homes ) y mujeres ( dones ), as\u00ed como el \u00e1rea en m\u00b2 de cada secci\u00f3n. Con estos datos, podemos calcular la densidad de poblaci\u00f3n en habitantes/km\u00b2 seg\u00fan la f\u00f3rmula: 1 densidad = (homes+dones)/(area/1000000) El estilo de mapbox-gl permite expresar operaciones matem\u00e1ticas usando expresiones , de la forma: [\"+\", [\"get\", \"homes\"], [\"get\", \"dones\"]] para sumar la poblaci\u00f3n de hombres y de mujeres [\"/\", [\"get\", \"area\"], 1000000] para pasar el \u00e1rea de m\u00b2 a km\u00b2 Y, combinando ambas, obtenemos la densidad de poblaci\u00f3n en habitantes/km\u00b2: 1 2 3 4 [ / , [ + , [ get , homes ], [ get , dones ]], [ / , [ get , area ], 1000000 ] ]","title":"Expresiones matem\u00e1ticas"},{"location":"7_servidor_dinamico/#rampas-de-color","text":"As\u00ed mismo, las expresiones de los estilos de mapbox-gl nos permiten aplicar un n\u00famero discreto de valores de salida a rangos de entrada . Las definiciones del manual sin un ejemplo concreto son algo dif\u00edciles de leer: 1 2 3 4 5 6 [ step , input: number , stop_output_ 0 : OutputType , stop_input_ 1 : number , stop_output_ 1 : OutputType , stop_input_n: number , stop_output_n: OutputType , ... ] : OutputType Pero supongamos que queremos aplicar esta expresi\u00f3n para asignar tres colores en funci\u00f3n de rangos de densidad ( 10.000 hab/km\u00b2 , de 10.000 a 25.000 hab/km\u00b2 , y 25.000 hab/km\u00b2 ), la expresi\u00f3n ser\u00eda: 1 2 3 4 5 6 [ step , [ get , densidad ], Color_1 , 10000 , Color_2 , 25000 , Color_3 ] M\u00e1s sencillo de lo que parec\u00eda.","title":"Rampas de color"},{"location":"7_servidor_dinamico/#combinando-ambas-expresiones","text":"Podemos combinar ambas expresiones: \"calcula la densidad y luego asigna un color en funci\u00f3n de su valor\" 1 2 3 4 5 6 7 8 9 10 11 12 13 [ step , [ / , [ + , [ get , homes ], [ get , dones ]], [ / , [ get , area ], 1000000 ] ], #3d5941 , 17703 , #778868 , 29678 , #b5b991 , 37617 , #f6edbd , 46016 , #edbb8a , 54401 , #de8a5a , 66570 , #ca562c ] Tip Los valores de corte para los diferentes colore se han obtenido calculando los cuantiles con PostgreSQL: 1 2 3 4 5 6 7 SELECT ntile , CAST ( min ( densitat ) AS INTEGER ) AS minAmount , CAST ( max ( densitat ) AS INTEGER ) AS maxAmount FROM ( SELECT ( homes + dones ) / ( area / 1000000 ) as densitat , ntile ( 7 ) OVER ( ORDER BY ( homes + dones ) / ( area / 1000000 )) AS ntile FROM seccion_censal ) x GROUP BY ntile ORDER BY ntile ; Y la rampa de color y sus valores RGB de cada color se han obtenido de carto-colors , que a su vez est\u00e1n inspirados en ColorBrewer. Aplicada a la propiedad fill-color del estilo: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 map . addLayer ({ id : seccion_censal , source : bcn_geodata , source-layer : seccion_censal , type : fill , paint : { fill-opacity : 0.75 , fill-color : [ step , [ / , [ + , [ get , homes ], [ get , dones ]], [ / , [ get , area ], 1000000 ] ], #3d5941 , 17703 , #778868 , 29678 , #b5b991 , 37617 , #f6edbd , 46016 , #edbb8a , 54401 , #de8a5a , 66570 , #ca562c ], fill-outline-color : #000 } }); Obtendremos:","title":"Combinando ambas expresiones"},{"location":"7_servidor_dinamico/#ejercicio-extra-anadir-extrusion-3d","text":"Aplicar una extrusi\u00f3n a cada secci\u00f3n censal de altura proporcional a su densidad de poblaci\u00f3n:","title":"Ejercicio extra: A\u00f1adir extrusi\u00f3n 3D"},{"location":"8_postgis_vt/","text":"C\u00f3mo servir datos desde PostGIS A partir de la versi\u00f3n 2.4.0 de PostGIS est\u00e1n disponibles dos nuevas funciones ST_AsMVTGeom y ST_AsMVT Funci\u00f3n ST_AsMVTGeom La funci\u00f3n ST_AsMVTGeom transforma una geometr\u00eda al espacio de coordenadas de una tesela vectorial. Transforma las coordenadas de una geometr\u00eda en coordenadas dentro de una tesela. Ejemplo para la capa barrios y la tesela 14/8289/6119 z=14 x=8289 y=6119 1 2 3 4 5 6 7 8 9 10 11 SELECT gid , c_distri , n_distri , c_barri , n_barri , homes , dones , area , ST_AsMvtGeom ( geom , BBox ( 14 , 8289 , 6119 ), 4096 , 256 , true ) AS geom FROM public . barrios WHERE geom BBox ( 14 , 8289 , 6119 ) AND ST_Intersects ( geom , BBox ( 14 , 8289 , 6119 )); Funci\u00f3n ST_AsMVT La funci\u00f3n ST_AsMVT codifica una geometr\u00eda en coordenadas de teselas como una capa (Layer) mvt (pbf) Ejemplo para la capa barrios y la tesela 14/8289/6119 1 2 3 4 5 6 7 8 9 10 11 12 13 14 SELECT ST_AsMVT ( q , barrios , 4096 , geom ) FROM ( SELECT gid , c_distri , n_distri , c_barri , n_barri , homes , dones , area , ST_AsMvtGeom ( geom , BBox ( 14 , 8289 , 6119 ), 4096 , 256 , true ) AS geom FROM public . barrios WHERE geom BBox ( 14 , 8289 , 6119 ) AND ST_Intersects ( geom , BBox ( 14 , 8289 , 6119 )) ) AS q ; Como un mvt es una succesion de capas, para crear un vector tile multicapa se pueden concatenar varias consultas. Funci\u00f3n BBox Funci\u00f3n que convierte las coordenadas de una tesela (z,x,y) en su correspondiente caja de coordenadas (bbox) en webmercator (EPSG:3857) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 CREATE OR REPLACE FUNCTION BBox ( zoom integer , x integer , y integer ) RETURNS geometry AS $ BODY$ DECLARE max numeric : = 6378137 * pi (); --20037508.34; res numeric : = max * 2 / 2 ^ zoom ; bbox geometry ; BEGIN return ST_MakeEnvelope ( - max + ( x * res ), max - ( y * res ), - max + ( x * res ) + res , max - ( y * res ) - res , 3857 ); END ; $ BODY$ LANGUAGE plpgsql IMMUTABLE ; En nuestro caso utilizaremos una funci\u00f3n un poco m\u00e1s generalista que permite indicar el srid 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 CREATE OR REPLACE FUNCTION public . tilebbox ( z integer , x integer , y integer , srid integer DEFAULT 3857 ) RETURNS geometry LANGUAGE plpgsql COST 100 IMMUTABLE AS $ BODY$ declare max numeric : = 20037508 . 34 ; --6378137 * pi(); res numeric : = ( max * 2 ) / ( 2 ^ z ); bbox geometry ; begin bbox : = ST_MakeEnvelope ( - max + ( x * res ), max - ( y * res ), - max + ( x * res ) + res , max - ( y * res ) - res , 3857 ); if srid = 3857 then return bbox ; else return ST_Transform ( bbox , srid ); end if ; end ; $ BODY$ ; ALTER FUNCTION public . tilebbox ( integer , integer , integer , integer ) OWNER TO postgres ; Crear la base de datos Warning Si ya hemos creado la base de datos en el apartado anterior ignorar esta parte Descargamos el archivo que contiene el script de creacion de la base de datos y las tablas correspondientes 1 wget https://raw.githubusercontent.com/geoinquiets/taller-vt/master/resultado/datos/bcn_geodata.sql Modificamos el archivo bcn_geodata.sql y remplazamos donde dice owner \"user\" por owner \"postgres\" . Una vez modificado el archivo cargamos el script con psql 1 psql -U postgres -h localhost bcn_geodata.sql Combinar varias capas en una misma tesela Como comentamos anteriormente \"un mvt es una succesion de capas, para crear un vector tile multicapa se pueden concatenar varias consultas\" . Para combinar varias capas en una misma tesela podemos utilizar una serie de funciones desarrolladas por el ICGC https://github.com/gencat/ICGC-vt-postgis que facilitan este trabajo. Descargar el archivo que permite crear las funciones y el esquema 1 wget https://raw.githubusercontent.com/gencat/ICGC-vt-postgis/master/icgc-vt-postgis-create.sql Crear el esquema y las funciones en la base de datos de bcn_geodata 1 psql -U postgres -d bcn_geodata -h localhost -f icgc-vt-postgis-create.sql Agregar la funcion tilebbox en nuestra base de datos y agregar las capas en la tabla icgc_vt.layers 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 CREATE OR REPLACE FUNCTION public . tilebbox ( z integer , x integer , y integer , srid integer DEFAULT 3857 ) RETURNS geometry LANGUAGE plpgsql COST 100 IMMUTABLE AS $ BODY$ declare max numeric : = 20037508 . 34 ; --6378137 * pi(); res numeric : = ( max * 2 ) / ( 2 ^ z ); bbox geometry ; begin bbox : = ST_MakeEnvelope ( - max + ( x * res ), max - ( y * res ), - max + ( x * res ) + res , max - ( y * res ) - res , 3857 ); if srid = 3857 then return bbox ; else return ST_Transform ( bbox , srid ); end if ; end ; $ BODY$ ; ALTER FUNCTION public . tilebbox ( integer , integer , integer , integer ) OWNER TO postgres ; INSERT INTO icgc_vt . layers ( name , geometry_type , minz , maxz , sql ) VALUES ( barrios , POLYGON , 10 , 18 , SELECT ST_AsBinary(geom) AS geom, gid, c_distri, n_distri, c_barri, n_barri, homes, dones, area FROM public.barrios WHERE geom !BBOX! ); INSERT INTO icgc_vt . layers ( name , geometry_type , minz , maxz , sql ) VALUES ( distritos , POLYGON , 10 , 18 , SELECT ST_AsBinary(geom) AS geom, gid, c_distri, n_distri, homes, dones, area FROM public.distritos WHERE geom !BBOX! ); INSERT INTO icgc_vt . layers ( name , geometry_type , minz , maxz , sql ) VALUES ( seccion_censal , POLYGON , 10 , 18 , SELECT ST_AsBinary(geom) AS geom, gid, c_distri, n_distri, c_barri, n_barri, c_aeb, c_seccens, homes, dones, area FROM public.seccion_censal WHERE geom !BBOX! ); Podemos comprobar que la funcion que retorna todas las capas como una tesela funciona 1 SELECT icgc_vt . tile_pbf ( 15 , 16578 , 12236 ); Configurar un servidor web para que sirva las capas de postgis Crearemos un servidor web utilizando el express server que nos permita servir los datos de la base de datos como un Vector Tiles. Para ello utilizaremos una aplicaci\u00f3n desarrollada por el ICGC https://github.com/gencat/ICGC-vtServer Clonamos el repositorio 1 2 3 git clone https://github.com/gencat/ICGC-vtServer.git cd ICGC-vtServer Creamos el archivo .env que permitira la conexion a nuestra base de datos con el siguiente contenido 1 2 3 4 5 DB_USER=postgres DB_HOST=localhost DB_DATABASE=bcn_geodata DB_PASS=postgres DB_PORT=5432 Creamos un nuevo archivo el la carpeta de static con el nombre de bcn_geodata.json con el siguiente contenido 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 { version : 8 , name : ICGC , metadata : {}, center : [ 1.537786 , 41.837539 ], zoom : 12 , bearing : 0 , pitch : 0 , sources : { openmaptiles : { type : vector , tiles : [ http://localhost:3333/{z}/{x}/{y}.pbf ] } }, sprite : https://geoserveis.icgc.cat/contextmaps/sprites/sprite@1 , glyphs : https://geoserveis.icgc.cat/contextmaps/glyphs/{fontstack}/{range}.pbf , layers : [ { id : background , type : background , paint : { background-color : #f8f4f0 } }, { id : barrios , type : fill , source : openmaptiles , source-layer : barrios , layout : { visibility : visible }, paint : { fill-color : #ff0000 , fill-opacity : { base : 1 , stops : [ [ 9 , 0.9 ], [ 22 , 0.3 ] ] } } } ], id : bcn-geodata } Modificar el archivo static/index3.html para que cargue nuestro estilo 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 !DOCTYPE html html head meta charset = utf-8 / title Swipe between maps / title meta name = viewport content = initial-scale=1,maximum-scale=1,user-scalable=no / script src = https://api.tiles.mapbox.com/mapbox-gl-js/v0.49.0/mapbox-gl.js / script link href = https://api.tiles.mapbox.com/mapbox-gl-js/v0.49.0/mapbox-gl.css rel = stylesheet / style body { margin : 0 ; padding : 0 ; } # map { position : absolute ; top : 0 ; bottom : 0 ; width : 100 % ; } / style / head body style body { overflow : hidden ; } body * { -webkit- touch-callout : none ; -webkit- user-select : none ; -moz- user-select : none ; -ms- user-select : none ; user-select : none ; } . map { position : absolute ; top : 0 ; bottom : 0 ; width : 100 % ; } / style div id = after class = map / div script var afterMap = new mapboxgl . Map ({ container : after , style : bcn_geodata.json , center : [ 2.16859 , 41.3954 ], zoom : 13 , maxZoom : 16 , hash : true , pitch : 45 }); afterMap . on ( click , function ( e ) { var features = afterMap . queryRenderedFeatures ( e . point ); var description = JSON . stringify ( features , null , 2 ); console . log ( description ); /* new mapboxgl.Popup() .setLngLat(e.lngLat) .setHTML(description) .addTo(afterMap); */ }); / script / body / html Ejercicio Agregar las capas de distritos y seccion_censal al estilo bcn_geodata","title":"8. C\u00f3mo servir datos desde PostGIS"},{"location":"8_postgis_vt/#como-servir-datos-desde-postgis","text":"A partir de la versi\u00f3n 2.4.0 de PostGIS est\u00e1n disponibles dos nuevas funciones ST_AsMVTGeom y ST_AsMVT","title":"C\u00f3mo servir datos desde PostGIS"},{"location":"8_postgis_vt/#funcion-st_asmvtgeom","text":"La funci\u00f3n ST_AsMVTGeom transforma una geometr\u00eda al espacio de coordenadas de una tesela vectorial. Transforma las coordenadas de una geometr\u00eda en coordenadas dentro de una tesela. Ejemplo para la capa barrios y la tesela 14/8289/6119 z=14 x=8289 y=6119 1 2 3 4 5 6 7 8 9 10 11 SELECT gid , c_distri , n_distri , c_barri , n_barri , homes , dones , area , ST_AsMvtGeom ( geom , BBox ( 14 , 8289 , 6119 ), 4096 , 256 , true ) AS geom FROM public . barrios WHERE geom BBox ( 14 , 8289 , 6119 ) AND ST_Intersects ( geom , BBox ( 14 , 8289 , 6119 ));","title":"Funci\u00f3n ST_AsMVTGeom"},{"location":"8_postgis_vt/#funcion-st_asmvt","text":"La funci\u00f3n ST_AsMVT codifica una geometr\u00eda en coordenadas de teselas como una capa (Layer) mvt (pbf) Ejemplo para la capa barrios y la tesela 14/8289/6119 1 2 3 4 5 6 7 8 9 10 11 12 13 14 SELECT ST_AsMVT ( q , barrios , 4096 , geom ) FROM ( SELECT gid , c_distri , n_distri , c_barri , n_barri , homes , dones , area , ST_AsMvtGeom ( geom , BBox ( 14 , 8289 , 6119 ), 4096 , 256 , true ) AS geom FROM public . barrios WHERE geom BBox ( 14 , 8289 , 6119 ) AND ST_Intersects ( geom , BBox ( 14 , 8289 , 6119 )) ) AS q ; Como un mvt es una succesion de capas, para crear un vector tile multicapa se pueden concatenar varias consultas.","title":"Funci\u00f3n ST_AsMVT"},{"location":"8_postgis_vt/#funcion-bbox","text":"Funci\u00f3n que convierte las coordenadas de una tesela (z,x,y) en su correspondiente caja de coordenadas (bbox) en webmercator (EPSG:3857) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 CREATE OR REPLACE FUNCTION BBox ( zoom integer , x integer , y integer ) RETURNS geometry AS $ BODY$ DECLARE max numeric : = 6378137 * pi (); --20037508.34; res numeric : = max * 2 / 2 ^ zoom ; bbox geometry ; BEGIN return ST_MakeEnvelope ( - max + ( x * res ), max - ( y * res ), - max + ( x * res ) + res , max - ( y * res ) - res , 3857 ); END ; $ BODY$ LANGUAGE plpgsql IMMUTABLE ; En nuestro caso utilizaremos una funci\u00f3n un poco m\u00e1s generalista que permite indicar el srid 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 CREATE OR REPLACE FUNCTION public . tilebbox ( z integer , x integer , y integer , srid integer DEFAULT 3857 ) RETURNS geometry LANGUAGE plpgsql COST 100 IMMUTABLE AS $ BODY$ declare max numeric : = 20037508 . 34 ; --6378137 * pi(); res numeric : = ( max * 2 ) / ( 2 ^ z ); bbox geometry ; begin bbox : = ST_MakeEnvelope ( - max + ( x * res ), max - ( y * res ), - max + ( x * res ) + res , max - ( y * res ) - res , 3857 ); if srid = 3857 then return bbox ; else return ST_Transform ( bbox , srid ); end if ; end ; $ BODY$ ; ALTER FUNCTION public . tilebbox ( integer , integer , integer , integer ) OWNER TO postgres ;","title":"Funci\u00f3n BBox"},{"location":"8_postgis_vt/#crear-la-base-de-datos","text":"Warning Si ya hemos creado la base de datos en el apartado anterior ignorar esta parte Descargamos el archivo que contiene el script de creacion de la base de datos y las tablas correspondientes 1 wget https://raw.githubusercontent.com/geoinquiets/taller-vt/master/resultado/datos/bcn_geodata.sql Modificamos el archivo bcn_geodata.sql y remplazamos donde dice owner \"user\" por owner \"postgres\" . Una vez modificado el archivo cargamos el script con psql 1 psql -U postgres -h localhost bcn_geodata.sql","title":"Crear la base de datos"},{"location":"8_postgis_vt/#combinar-varias-capas-en-una-misma-tesela","text":"Como comentamos anteriormente \"un mvt es una succesion de capas, para crear un vector tile multicapa se pueden concatenar varias consultas\" . Para combinar varias capas en una misma tesela podemos utilizar una serie de funciones desarrolladas por el ICGC https://github.com/gencat/ICGC-vt-postgis que facilitan este trabajo. Descargar el archivo que permite crear las funciones y el esquema 1 wget https://raw.githubusercontent.com/gencat/ICGC-vt-postgis/master/icgc-vt-postgis-create.sql Crear el esquema y las funciones en la base de datos de bcn_geodata 1 psql -U postgres -d bcn_geodata -h localhost -f icgc-vt-postgis-create.sql Agregar la funcion tilebbox en nuestra base de datos y agregar las capas en la tabla icgc_vt.layers 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 CREATE OR REPLACE FUNCTION public . tilebbox ( z integer , x integer , y integer , srid integer DEFAULT 3857 ) RETURNS geometry LANGUAGE plpgsql COST 100 IMMUTABLE AS $ BODY$ declare max numeric : = 20037508 . 34 ; --6378137 * pi(); res numeric : = ( max * 2 ) / ( 2 ^ z ); bbox geometry ; begin bbox : = ST_MakeEnvelope ( - max + ( x * res ), max - ( y * res ), - max + ( x * res ) + res , max - ( y * res ) - res , 3857 ); if srid = 3857 then return bbox ; else return ST_Transform ( bbox , srid ); end if ; end ; $ BODY$ ; ALTER FUNCTION public . tilebbox ( integer , integer , integer , integer ) OWNER TO postgres ; INSERT INTO icgc_vt . layers ( name , geometry_type , minz , maxz , sql ) VALUES ( barrios , POLYGON , 10 , 18 , SELECT ST_AsBinary(geom) AS geom, gid, c_distri, n_distri, c_barri, n_barri, homes, dones, area FROM public.barrios WHERE geom !BBOX! ); INSERT INTO icgc_vt . layers ( name , geometry_type , minz , maxz , sql ) VALUES ( distritos , POLYGON , 10 , 18 , SELECT ST_AsBinary(geom) AS geom, gid, c_distri, n_distri, homes, dones, area FROM public.distritos WHERE geom !BBOX! ); INSERT INTO icgc_vt . layers ( name , geometry_type , minz , maxz , sql ) VALUES ( seccion_censal , POLYGON , 10 , 18 , SELECT ST_AsBinary(geom) AS geom, gid, c_distri, n_distri, c_barri, n_barri, c_aeb, c_seccens, homes, dones, area FROM public.seccion_censal WHERE geom !BBOX! ); Podemos comprobar que la funcion que retorna todas las capas como una tesela funciona 1 SELECT icgc_vt . tile_pbf ( 15 , 16578 , 12236 );","title":"Combinar varias capas en una misma tesela"},{"location":"8_postgis_vt/#configurar-un-servidor-web-para-que-sirva-las-capas-de-postgis","text":"Crearemos un servidor web utilizando el express server que nos permita servir los datos de la base de datos como un Vector Tiles. Para ello utilizaremos una aplicaci\u00f3n desarrollada por el ICGC https://github.com/gencat/ICGC-vtServer Clonamos el repositorio 1 2 3 git clone https://github.com/gencat/ICGC-vtServer.git cd ICGC-vtServer Creamos el archivo .env que permitira la conexion a nuestra base de datos con el siguiente contenido 1 2 3 4 5 DB_USER=postgres DB_HOST=localhost DB_DATABASE=bcn_geodata DB_PASS=postgres DB_PORT=5432 Creamos un nuevo archivo el la carpeta de static con el nombre de bcn_geodata.json con el siguiente contenido 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 { version : 8 , name : ICGC , metadata : {}, center : [ 1.537786 , 41.837539 ], zoom : 12 , bearing : 0 , pitch : 0 , sources : { openmaptiles : { type : vector , tiles : [ http://localhost:3333/{z}/{x}/{y}.pbf ] } }, sprite : https://geoserveis.icgc.cat/contextmaps/sprites/sprite@1 , glyphs : https://geoserveis.icgc.cat/contextmaps/glyphs/{fontstack}/{range}.pbf , layers : [ { id : background , type : background , paint : { background-color : #f8f4f0 } }, { id : barrios , type : fill , source : openmaptiles , source-layer : barrios , layout : { visibility : visible }, paint : { fill-color : #ff0000 , fill-opacity : { base : 1 , stops : [ [ 9 , 0.9 ], [ 22 , 0.3 ] ] } } } ], id : bcn-geodata } Modificar el archivo static/index3.html para que cargue nuestro estilo 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 !DOCTYPE html html head meta charset = utf-8 / title Swipe between maps / title meta name = viewport content = initial-scale=1,maximum-scale=1,user-scalable=no / script src = https://api.tiles.mapbox.com/mapbox-gl-js/v0.49.0/mapbox-gl.js / script link href = https://api.tiles.mapbox.com/mapbox-gl-js/v0.49.0/mapbox-gl.css rel = stylesheet / style body { margin : 0 ; padding : 0 ; } # map { position : absolute ; top : 0 ; bottom : 0 ; width : 100 % ; } / style / head body style body { overflow : hidden ; } body * { -webkit- touch-callout : none ; -webkit- user-select : none ; -moz- user-select : none ; -ms- user-select : none ; user-select : none ; } . map { position : absolute ; top : 0 ; bottom : 0 ; width : 100 % ; } / style div id = after class = map / div script var afterMap = new mapboxgl . Map ({ container : after , style : bcn_geodata.json , center : [ 2.16859 , 41.3954 ], zoom : 13 , maxZoom : 16 , hash : true , pitch : 45 }); afterMap . on ( click , function ( e ) { var features = afterMap . queryRenderedFeatures ( e . point ); var description = JSON . stringify ( features , null , 2 ); console . log ( description ); /* new mapboxgl.Popup() .setLngLat(e.lngLat) .setHTML(description) .addTo(afterMap); */ }); / script / body / html","title":"Configurar un servidor web para que sirva las capas de postgis"},{"location":"8_postgis_vt/#ejercicio","text":"Agregar las capas de distritos y seccion_censal al estilo bcn_geodata","title":"Ejercicio"},{"location":"9_geoserver_vts/","text":"Servir vector tiles desde GeoServer GeoServer est\u00e1 preparado para servir teselas vectoriales en tres formatos diferentes: GeoJSON TopoJSON y las vector tiles de Mapbox. Formato MIME Descripci\u00f3n Mapbox Vector (MVT) application/vnd.mapbox-vector-tile Formato Recomendado GeoJSON application/json;type=geojson No soportado por muchos de los clientes de Vector Tiles TopoJSON application/json;type=topojson M\u00e1s complejo que el GeoJSON por gestionar la topolog\u00eda. No est\u00e1 soportado por muchos clientes GeoServer soporta Vector Tiles a trav\u00e9s de GeoWebCache, por lo que ser\u00e1 este el que se encargue de gestionar las capas que ser\u00e1n consumidas en este formato. Lo primero para poder usar Vector Tiles con GeoServer ser\u00e1 instalar la librer\u00eda que le da soporte. Instalar la extensi\u00f3n de Vector Tiles en GeoServer Para instalar la extensi\u00f3n de GeoServer que nos permita usar vector tiles lo primero que haremos ser\u00e1 descargar la librer\u00eda de la versi\u00f3n de geoserver que estemos utilizando (para este ejemplo es la versi\u00f3n 2.14.4): 1 wget http://sourceforge.net/projects/geoserver/files/GeoServer/2.14.4/extensions/geoserver-2.14.4-vectortiles-plugin.zip Extraeremos el contenido del archivo en la carpeta WEB-INF-lib de nuestra instalaci\u00f3n de GeoServer 1 unzip geoserver-2.14.4-vectortiles-plugin.zip -d $GEOSERVER_DIR /WEB-INF/lib/ Reiniciaremos nuestro GeoServer y ya tendr\u00edamos la extensi\u00f3n instalada. Para comprobar que la extensi\u00f3n se ha instalado correctamente iremos al administrador web de GeoServer y seleccionaremos una capa de tipo vectorial, navegaremos hasta la pesta\u00f1a de Tile Caching y comprobaremos que aparecen las opciones: application/json;type=geojson application/json;type=topojson application/vnd.mapbox-vector-tile Publicar Vector Tiles en GeoServer Para publicar una capa vectorial como vector tiles simplemente seleccionaremos una capa de tipo vectorial que queramos publicar y seleccionaremos en la opci\u00f3n de Tile Caching cualquiera de los formatos de vector tiles que est\u00e1n disponibles. Se recomienda el uso de application/vnd.mapbox-vector-tile En nuestro ejemplo de la base de datos bcn_geodata publicaremos la capa de secciones censales Una vez que tengamos la capa publicada podremos comprobar que esta se ha cacheado simplemente accediendo a la instancia de GeoWebCache instalada junto a nuestro GeoServer. En la web de administraci\u00f3n de GeoServer seleccionaremos la secci\u00f3n de Tile Caching , Tile Layers y deber\u00edamos encontrar un listado de las capas que tenemos publicadas y cacheadas. Desde la secci\u00f3n de Preview de cada capa tendremos la opci\u00f3n de visualizar los datos en formato pbf que es el formato de transferencia de las Vector Tiles Si seleccionamos uno de estos formatos accederemos al visor de GeoWebCache donde visualizaremos la capa. Publicar las capas como grupos de capas Como ya se ha comentado a lo largo del tutorial, el formato de vector tiles nos permite enviar informaci\u00f3n de diferentes capas en una misma tesela. Para realizar esto con GeoServer, tendremos que generar un grupo de capas con los datos que nos interese y publicarlos de la misma manera que las capas anteriores. Warning Todas las capas que formen el grupo de capas deber\u00e1n estar publicadas con el formato de vector tiles que queramos usar. En nuestro caso application/vnd.mapbox-vector-tile Consumir las vector tiles publicadas desde GeoServer Para consumir las vector tiles que tenemos publicadas en nuestro GeoServer, en este caso, definiremos un estilo con las capas publicadas como source-layer mientras que el source de los datos ser\u00e1 la URL de nuestro GeoWebCache donde est\u00e1 publicada el grupo de capas. El estilo lo guardaremos como vectortiles-geoserver.json dentro de la carpeta resultado/vectortiles 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 { version : 8 , name : VectorTiles GeoServer , id : vectortiles-geoserver , metadata : { mapbox:autocomposite : false , mapbox:type : template , maputnik:renderer : mbgljs , openmaptiles:version : 3.x }, sources : { }, sprite : https://geoserveis.icgc.cat/contextmaps/sprites/sprite@1 , glyphs : https://geoserveis.icgc.cat/contextmaps/glyphs/{fontstack}/{range}.pbf , layers : [ ] } Lo primero que deberemos definir es el source de los datos. Para ello definiremos un source de tipo vector . Deberemos definir el esquema de las teselas como tms y la url de las teselas la url del GeoWebCache: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 { version : 8 , name : VectorTiles GeoServer , id : vectortiles-geoserver , metadata : { mapbox:autocomposite : false , mapbox:type : template , maputnik:renderer : mbgljs , openmaptiles:version : 3.x }, sources : { bcn_geodata : { tiles : [ http://localhost:8090/geowebcache/service/tms/1.0.0/vectortiles:bcn_geodata@EPSG:900913@pbf/{z}/{x}/{y}.pbf ], scheme : tms , type : vector } }, sprite : https://geoserveis.icgc.cat/contextmaps/sprites/sprite@1 , glyphs : https://geoserveis.icgc.cat/contextmaps/glyphs/{fontstack}/{range}.pbf , layers : [ ] } La URL donde se est\u00e1n publicando las teselas se compone de la siguiente manera: URL del GeoWebCache: http://localhost:8090/geoserver/gwc/ Definici\u00f3n del servicio TMS service/tms/1.0.0/ Definici\u00f3n de la capa en la manera layer@gridset@formato/{z}/{x}/{y}.pbf , bcn_geodata@EPSG:900913@pbf/{z}/{x}/{y}.pbf Las capas las definiremos como en los ejemplos anteriores: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 { version : 8 , name : VectorTiles GeoServer , id : vectortiles-geoserver , metadata : { mapbox:autocomposite : false , mapbox:type : template , maputnik:renderer : mbgljs , openmaptiles:version : 3.x }, sources : { bcn_geodata : { tiles : [ http://localhost:8090/geowebcache/service/tms/1.0.0/vectortiles:bcn_geodata@EPSG:900913@pbf/{z}/{x}/{y}.pbf ], scheme : tms , type : vector } }, sprite : https://geoserveis.icgc.cat/contextmaps/sprites/sprite@1 , glyphs : https://geoserveis.icgc.cat/contextmaps/glyphs/{fontstack}/{range}.pbf , layers : [ { id : barrios , type : fill , source : bcn_geodata , source-layer : barrios , layout : { visibility : visible }, paint : { fill-color : #ff0000 , fill-opacity : { base : 1 , stops : [ [ 9 , 0.9 ], [ 22 , 0.3 ] ] } } }, { id : seccion_censal , source : bcn_geodata , source-layer : seccion_censal , type : fill , paint : { fill-opacity : 0.6 , fill-color : #fcc , fill-outline-color : #000 } } ] } Ahora construiremos un peque\u00f1o visor para consumir nuestros datos como ya hicimos en ejemplos anteriores. Para ello creamos un fichero index.html dentro de la carpeta resultado/vectortiles con el siguiente contenido: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 !DOCTYPE html html head meta charset = UTF-8 meta name = viewport content = width=device-width, initial-scale=1 title Mapa VT / title link rel = stylesheet href = https://api.tiles.mapbox.com/mapbox-gl-js/v0.44.1/mapbox-gl.css / script src = https://api.tiles.mapbox.com/mapbox-gl-js/v0.44.1/mapbox-gl.js / script link href = https://mapbox-gl-inspect.lukasmartinelli.ch/dist/mapbox-gl-inspect.css rel = stylesheet / script src = https://mapbox-gl-inspect.lukasmartinelli.ch/dist/mapbox-gl-inspect.min.js / script style html , body { margin : 0 ; height : 100 % ; } / style / head body id = map script var map = new mapboxgl . Map ({ container : map , // id del elemento HTML que contendr\u00e1 el mapa style : ./vectortiles-geoserver.json , // Ubicaci\u00f3n del estilo center : [ 2.19224 , 41.38585 ], zoom : 15 , bearing : - 45 , hash : true }); // Agrega controles de navegaci\u00f3n (zoom, rotaci\u00f3n) al mapa: map . addControl ( new mapboxgl . NavigationControl ()); // Agregar el control de inspecci\u00f3n map . addControl ( new MapboxInspect ()); / script / body / html Usaremos cualquier servidor web para publicar el contenido de la carpeta y accederemos desde nuestro navegador a la url publicada por este servidor donde visualizaremos","title":"9. Servir vector tiles desde GeoServer"},{"location":"9_geoserver_vts/#servir-vector-tiles-desde-geoserver","text":"GeoServer est\u00e1 preparado para servir teselas vectoriales en tres formatos diferentes: GeoJSON TopoJSON y las vector tiles de Mapbox. Formato MIME Descripci\u00f3n Mapbox Vector (MVT) application/vnd.mapbox-vector-tile Formato Recomendado GeoJSON application/json;type=geojson No soportado por muchos de los clientes de Vector Tiles TopoJSON application/json;type=topojson M\u00e1s complejo que el GeoJSON por gestionar la topolog\u00eda. No est\u00e1 soportado por muchos clientes GeoServer soporta Vector Tiles a trav\u00e9s de GeoWebCache, por lo que ser\u00e1 este el que se encargue de gestionar las capas que ser\u00e1n consumidas en este formato. Lo primero para poder usar Vector Tiles con GeoServer ser\u00e1 instalar la librer\u00eda que le da soporte.","title":"Servir vector tiles desde GeoServer"},{"location":"9_geoserver_vts/#instalar-la-extension-de-vector-tiles-en-geoserver","text":"Para instalar la extensi\u00f3n de GeoServer que nos permita usar vector tiles lo primero que haremos ser\u00e1 descargar la librer\u00eda de la versi\u00f3n de geoserver que estemos utilizando (para este ejemplo es la versi\u00f3n 2.14.4): 1 wget http://sourceforge.net/projects/geoserver/files/GeoServer/2.14.4/extensions/geoserver-2.14.4-vectortiles-plugin.zip Extraeremos el contenido del archivo en la carpeta WEB-INF-lib de nuestra instalaci\u00f3n de GeoServer 1 unzip geoserver-2.14.4-vectortiles-plugin.zip -d $GEOSERVER_DIR /WEB-INF/lib/ Reiniciaremos nuestro GeoServer y ya tendr\u00edamos la extensi\u00f3n instalada. Para comprobar que la extensi\u00f3n se ha instalado correctamente iremos al administrador web de GeoServer y seleccionaremos una capa de tipo vectorial, navegaremos hasta la pesta\u00f1a de Tile Caching y comprobaremos que aparecen las opciones: application/json;type=geojson application/json;type=topojson application/vnd.mapbox-vector-tile","title":"Instalar la extensi\u00f3n de Vector Tiles en GeoServer"},{"location":"9_geoserver_vts/#publicar-vector-tiles-en-geoserver","text":"Para publicar una capa vectorial como vector tiles simplemente seleccionaremos una capa de tipo vectorial que queramos publicar y seleccionaremos en la opci\u00f3n de Tile Caching cualquiera de los formatos de vector tiles que est\u00e1n disponibles. Se recomienda el uso de application/vnd.mapbox-vector-tile En nuestro ejemplo de la base de datos bcn_geodata publicaremos la capa de secciones censales Una vez que tengamos la capa publicada podremos comprobar que esta se ha cacheado simplemente accediendo a la instancia de GeoWebCache instalada junto a nuestro GeoServer. En la web de administraci\u00f3n de GeoServer seleccionaremos la secci\u00f3n de Tile Caching , Tile Layers y deber\u00edamos encontrar un listado de las capas que tenemos publicadas y cacheadas. Desde la secci\u00f3n de Preview de cada capa tendremos la opci\u00f3n de visualizar los datos en formato pbf que es el formato de transferencia de las Vector Tiles Si seleccionamos uno de estos formatos accederemos al visor de GeoWebCache donde visualizaremos la capa.","title":"Publicar Vector Tiles en GeoServer"},{"location":"9_geoserver_vts/#publicar-las-capas-como-grupos-de-capas","text":"Como ya se ha comentado a lo largo del tutorial, el formato de vector tiles nos permite enviar informaci\u00f3n de diferentes capas en una misma tesela. Para realizar esto con GeoServer, tendremos que generar un grupo de capas con los datos que nos interese y publicarlos de la misma manera que las capas anteriores. Warning Todas las capas que formen el grupo de capas deber\u00e1n estar publicadas con el formato de vector tiles que queramos usar. En nuestro caso application/vnd.mapbox-vector-tile","title":"Publicar las capas como grupos de capas"},{"location":"9_geoserver_vts/#consumir-las-vector-tiles-publicadas-desde-geoserver","text":"Para consumir las vector tiles que tenemos publicadas en nuestro GeoServer, en este caso, definiremos un estilo con las capas publicadas como source-layer mientras que el source de los datos ser\u00e1 la URL de nuestro GeoWebCache donde est\u00e1 publicada el grupo de capas. El estilo lo guardaremos como vectortiles-geoserver.json dentro de la carpeta resultado/vectortiles 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 { version : 8 , name : VectorTiles GeoServer , id : vectortiles-geoserver , metadata : { mapbox:autocomposite : false , mapbox:type : template , maputnik:renderer : mbgljs , openmaptiles:version : 3.x }, sources : { }, sprite : https://geoserveis.icgc.cat/contextmaps/sprites/sprite@1 , glyphs : https://geoserveis.icgc.cat/contextmaps/glyphs/{fontstack}/{range}.pbf , layers : [ ] } Lo primero que deberemos definir es el source de los datos. Para ello definiremos un source de tipo vector . Deberemos definir el esquema de las teselas como tms y la url de las teselas la url del GeoWebCache: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 { version : 8 , name : VectorTiles GeoServer , id : vectortiles-geoserver , metadata : { mapbox:autocomposite : false , mapbox:type : template , maputnik:renderer : mbgljs , openmaptiles:version : 3.x }, sources : { bcn_geodata : { tiles : [ http://localhost:8090/geowebcache/service/tms/1.0.0/vectortiles:bcn_geodata@EPSG:900913@pbf/{z}/{x}/{y}.pbf ], scheme : tms , type : vector } }, sprite : https://geoserveis.icgc.cat/contextmaps/sprites/sprite@1 , glyphs : https://geoserveis.icgc.cat/contextmaps/glyphs/{fontstack}/{range}.pbf , layers : [ ] } La URL donde se est\u00e1n publicando las teselas se compone de la siguiente manera: URL del GeoWebCache: http://localhost:8090/geoserver/gwc/ Definici\u00f3n del servicio TMS service/tms/1.0.0/ Definici\u00f3n de la capa en la manera layer@gridset@formato/{z}/{x}/{y}.pbf , bcn_geodata@EPSG:900913@pbf/{z}/{x}/{y}.pbf Las capas las definiremos como en los ejemplos anteriores: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 { version : 8 , name : VectorTiles GeoServer , id : vectortiles-geoserver , metadata : { mapbox:autocomposite : false , mapbox:type : template , maputnik:renderer : mbgljs , openmaptiles:version : 3.x }, sources : { bcn_geodata : { tiles : [ http://localhost:8090/geowebcache/service/tms/1.0.0/vectortiles:bcn_geodata@EPSG:900913@pbf/{z}/{x}/{y}.pbf ], scheme : tms , type : vector } }, sprite : https://geoserveis.icgc.cat/contextmaps/sprites/sprite@1 , glyphs : https://geoserveis.icgc.cat/contextmaps/glyphs/{fontstack}/{range}.pbf , layers : [ { id : barrios , type : fill , source : bcn_geodata , source-layer : barrios , layout : { visibility : visible }, paint : { fill-color : #ff0000 , fill-opacity : { base : 1 , stops : [ [ 9 , 0.9 ], [ 22 , 0.3 ] ] } } }, { id : seccion_censal , source : bcn_geodata , source-layer : seccion_censal , type : fill , paint : { fill-opacity : 0.6 , fill-color : #fcc , fill-outline-color : #000 } } ] } Ahora construiremos un peque\u00f1o visor para consumir nuestros datos como ya hicimos en ejemplos anteriores. Para ello creamos un fichero index.html dentro de la carpeta resultado/vectortiles con el siguiente contenido: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 !DOCTYPE html html head meta charset = UTF-8 meta name = viewport content = width=device-width, initial-scale=1 title Mapa VT / title link rel = stylesheet href = https://api.tiles.mapbox.com/mapbox-gl-js/v0.44.1/mapbox-gl.css / script src = https://api.tiles.mapbox.com/mapbox-gl-js/v0.44.1/mapbox-gl.js / script link href = https://mapbox-gl-inspect.lukasmartinelli.ch/dist/mapbox-gl-inspect.css rel = stylesheet / script src = https://mapbox-gl-inspect.lukasmartinelli.ch/dist/mapbox-gl-inspect.min.js / script style html , body { margin : 0 ; height : 100 % ; } / style / head body id = map script var map = new mapboxgl . Map ({ container : map , // id del elemento HTML que contendr\u00e1 el mapa style : ./vectortiles-geoserver.json , // Ubicaci\u00f3n del estilo center : [ 2.19224 , 41.38585 ], zoom : 15 , bearing : - 45 , hash : true }); // Agrega controles de navegaci\u00f3n (zoom, rotaci\u00f3n) al mapa: map . addControl ( new mapboxgl . NavigationControl ()); // Agregar el control de inspecci\u00f3n map . addControl ( new MapboxInspect ()); / script / body / html Usaremos cualquier servidor web para publicar el contenido de la carpeta y accederemos desde nuestro navegador a la url publicada por este servidor donde visualizaremos","title":"Consumir las vector tiles publicadas desde GeoServer"}]}